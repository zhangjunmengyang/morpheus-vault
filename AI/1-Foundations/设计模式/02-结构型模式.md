---
title: 结构型模式
tags: [design-pattern, structural]
date: 2026-02-28
---

# 结构型模式

> 核心问题：**如何组合对象和类**，形成更大的结构。
> 一句话：把已有的"积木"拼出新形状，而不是重新造积木。

---

## 1. 适配器（Adapter）

**问题**：两个接口不兼容，无法直接合作，但又不能改原有代码。

```
调用方  →  适配器  →  被适配对象
         (转换接口)

例：你的系统用 JSON，第三方 API 返回 XML
   你在中间加一个适配器，对外暴露 JSON 接口
```

**本质**：转换接口，让不兼容的东西能合作。现实类比：电源转接头。
**AI 映射**：
- 对接不同 LLM 厂商 API（统一封装为同一个调用接口）
- 把旧系统的 SQL 查询适配成 Agent 可理解的工具调用格式

---

## 2. 装饰器（Decorator）

**问题**：想给对象动态加功能，但不想改原来的类，也不想用继承（继承会爆炸）。

```
原始对象
  └─ 装饰器A（加日志）
       └─ 装饰器B（加缓存）
            └─ 装饰器C（加鉴权）
                 └─ 核心功能
```

**本质**：像套娃一样，每层包一个功能，层层叠加。
**vs 继承**：继承是编译时确定，装饰器是运行时动态叠加。
**AI 映射**：
- 给 Agent 动态加能力：基础 Agent + 加记忆层 + 加日志层 + 加限速层
- LangChain 的 Chain 本质就是装饰器链

---

## 3. 代理（Proxy）

**问题**：想在访问某个对象前后做一些额外工作（鉴权、缓存、延迟加载），但不想让调用方感知。

```
调用方  →  代理对象  →  真实对象
           (鉴权/缓存/日志)
```

**本质**：代理和真实对象实现同一个接口，调用方无感知。

三种常见代理：
- **保护代理**：鉴权（没权限就拦截）
- **缓存代理**：结果缓存，相同请求不重复计算
- **远程代理**：本地调用，实际执行在远端（RPC 的本质）

**vs 装饰器**：代理控制访问，装饰器增加功能。概念相近，意图不同。
**AI 映射**：
- 模型调用代理（限速、计费、fallback 到备用模型）
- Tool 调用代理（记录每次调用、做安全过滤）

---

## 4. 外观（Facade）

**问题**：子系统很复杂，调用方需要和很多组件打交道，能不能给我一个简单的统一入口？

```
调用方  →  Facade（统一入口）
                ├─→  子系统A
                ├─→  子系统B
                └─→  子系统C

调用方只和 Facade 打交道，不知道内部有多复杂
```

**本质**：简化接口，隐藏复杂度。现实类比：遥控器（不用知道电视内部电路）。
**AI 映射**：
- Agent Orchestrator 就是 Facade：对外暴露"帮我查航班"，内部协调搜索 Agent + 预订 Agent + 支付 Agent
- OpenAI Assistant API 对外是 Facade，内部管 Thread / Message / Run / Tool 的复杂状态

---

## 5. 桥接（Bridge）

**问题**：有两个维度在变化（比如形状×颜色），如果用继承会产生 M×N 个子类爆炸。

```
抽象层（形状）        实现层（颜色）
  圆形  ─────────────→  红色实现
  方形  ─────────────→  蓝色实现
  三角  ─────────────→  绿色实现

两个维度独立变化，通过组合而非继承连接
```

**本质**：把抽象和实现分离，各自独立扩展。
**AI 映射**：Agent 类型（搜索/写作/编码）× 底层模型（GPT-4/Claude/Gemini）独立变化，不用写 M×N 个组合类。

---

## 6. 组合（Composite）

**问题**：处理树形结构，希望对叶节点和组合节点用同一套接口操作。

```
任务
├── 子任务1（叶节点）
├── 子任务2（叶节点）
└── 子任务组（组合节点）
    ├── 子子任务A
    └── 子子任务B

对任意节点调用 execute()，叶节点直接执行，组合节点递归执行子节点
```

**本质**：统一叶节点和容器节点的接口，递归组合。
**AI 映射**：
- 任务分解树（Task Decomposition）：每个节点可以是原子任务或子任务组
- 多 Agent 的层级编排（Supervisor 下面管 Worker，Worker 下面还可以有 Sub-Worker）

---

## 7. 享元（Flyweight）

**问题**：大量相似对象消耗内存，能不能共享公共部分？

```
1000 个"士兵"对象
  共享部分（外观、动画数据）→  一份享元对象
  独立部分（位置、血量）    →  每个实例自己持有
```

**本质**：把不变的部分共享，只保留变化的部分在实例里。
**AI 映射**：大量 Agent 实例共享同一个基础模型权重，只有各自的上下文/状态不同（推理服务的本质）。

---

## 结构型模式对比

| 模式 | 核心意图 | 关键词 |
|------|---|---|
| 适配器 | 接口转换 | 不兼容→兼容 |
| 装饰器 | 动态加功能 | 套娃、运行时叠加 |
| 代理 | 控制访问 | 中间人、透明代理 |
| 外观 | 简化接口 | 统一入口、隐藏复杂度 |
| 桥接 | 分离两个变化维度 | 组合替代继承爆炸 |
| 组合 | 统一树形结构操作 | 递归、叶节点=组合节点 |
| 享元 | 共享复用减内存 | 大量相似对象 |
