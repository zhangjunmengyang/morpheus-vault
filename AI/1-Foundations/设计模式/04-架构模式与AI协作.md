---
title: 架构模式与 AI 协作
tags: [design-pattern, architecture, ai-collaboration, multi-agent]
date: 2026-02-28
---

# 架构模式与 AI 协作

> 这是老板最关心的部分。
> GoF 模式解决的是代码级设计问题，架构模式解决的是**系统级协作问题**。
> 对 AI Agent 系统来说，这些模式直接映射到真实的系统设计选择。

---

## 1. 管道-过滤器（Pipeline-Filter）⭐

**问题**：数据需要经过一系列处理步骤，每步独立、可替换、可组合。

````mermaid
flowchart TD
  n1["输入  →  [过滤器A]  →  [过滤器B]  →  [过滤器C]  →  输出"]
  n2["清洗          ��换          格式化"]
  n3["关键特性："]
  n4["- 每个过滤器只知道自己的输入和输出格式"]
  n5["- 过滤器之间通过\"管道\"传递数据"]
  n6["- 可以任意组合、重排、替换某一段"]
  n1 --> n2
  n2 --> n3
  n3 --> n4
  n4 --> n5
  n5 --> n6
````

**本质**：把复杂处理流程拆成独立可组合的小步骤。

**两种变体**：
- **线性管道**：A → B → C，严格串行
- **分支管道**：A → (B1 + B2 并行) → C（Fan-out / Fan-in）

**AI 映射**：
- RAG 管道：Query → 检索 → Rerank → 截断 → 生成 → 后处理
- 数据预处理管道：原始文档 → 清洗 → 分块 → 向量化 → 入库
- FARS 的四阶段：Ideation → Planning → Experiment → Writing
- LangChain Chain 本质是管道模式

**适合场景**：流程固定、步骤明确、数据单向流动。

---

## 2. 黑板模式（Blackboard）⭐

**问题**：多个专家（Agent）处理同一个复杂问题，没有人能单独解决，需要协同——但各专家擅长领域不同，不知道该何时介入。

````mermaid
flowchart TD
  n1["┌──────────────┐"]
  n2["│   黑板（共享）  │"]
  n3["│  问题状态      │"]
  n4["│  中间结果      │"]
  n5["│  当前假设      │"]
  n6["└──────┬───────┘"]
  n7["│ 读/写"]
  n8["┌──────────────────┼──────────────────┐"]
  n9["↓                  ↓                  ↓"]
  n10["[专家A]             [专家B]             [专家C]"]
  n11["语法分析            语义理解            背景知识"]
  n12["控制组件：监控黑板状态，决定激活哪个专家"]
  n1 --> n2
  n2 --> n3
  n3 --> n4
  n4 --> n5
  n5 --> n6
  n6 --> n7
  n7 --> n8
  n8 --> n9
  n9 --> n10
  n10 --> n11
  n11 --> n12
````

**本质**：
- **黑板**：所有人共享的工作区（状态 + 中间结果）
- **专家（知识源）**：独立的处理单元，监视黑板、贡献专业判断
- **控制组件**：决定谁下一步发言（可以是规则，也可以是竞价）

**核心特点**：
- 专家之间**不直接通信**，只通过黑板间接协作
- 没有固定流程，哪个专家"有话说"就写到黑板上
- 适合**渐进式求解**——问题答案不是一步算出来的，是多轮迭代收敛的

**经典案例**：HEARSAY-II 语音识别系统（1970s），是黑板模式的发明场景。

**AI 映射（你们刚上线的）**：
- 多 Agent 共享一个结构化的"工作区"（共享内存/数据库）
- 不同 Agent 负责不同维度的分析，结果都写入黑板
- 一个协调 Agent（或规则引擎）决定当前激活哪个 Agent
- 适合：复杂问题求解、多轮迭代分析、需要多个专业视角综合的场景

**vs 管道**：管道流程固定（A→B→C），黑板流程动态（谁有贡献谁写）。

---

## 3. 发布-订阅（Pub/Sub）⭐

**问题**：事件的发布方不应该知道谁在监听，订阅方不应该知道谁在发布——完全解耦。

````mermaid
flowchart TD
  n1["发布方A  ──→┐"]
  n2["发布方B  ──→│  消息总线 / 事件队列  ──→ 订阅方X（订阅了主题1）"]
  n3["发布方C  ──→┘  (Topic 1, 2, 3)    ──→ 订阅方Y（订阅了主题1+2）"]
  n4["──→ 订阅方Z（订阅了主题2+3）"]
  n1 --> n2
  n2 --> n3
  n3 --> n4
````

**vs 观察者**：
````mermaid
flowchart TD
  n1["观察者模式：Subject 直接持有观察者列表（知道对方是谁）"]
  n2["Pub/Sub：   发布方和订阅方都只认识\"总线\"（完全匿名）"]
  n1 --> n2
````

**AI 映射**：
- 事件驱动的 Agent 协调：用户消息 → 发布到总线 → 意图识别/记忆检索/工具准备 并发订阅
- 异步任务通知：长时间任务完成 → 发布事件 → 通知相关等待方
- 多 Agent 松耦合协作（新加 Agent 只需订阅相关 topic，不改现有代码）

---

## 4. 监督者模式（Supervisor）⭐

**问题**：子进程/子任务失败了，需要有人监控并决定重启、忽略还是升级错误。

````mermaid
flowchart TD
  n1["┌─────────────────┐"]
  n2["│    Supervisor   │"]
  n3["│  监控 + 决策策略  │"]
  n4["└────────┬────────┘"]
  n5["┌──────────────┼──────────────┐"]
  n6["↓              ↓              ↓"]
  n7["Worker A       Worker B       Worker C"]
  n8["（正常）        （失败）        （正常）"]
  n9["│"]
  n10["Supervisor 收到失败信号"]
  n11["决策：重启 / 换一个 / 升级"]
  n1 --> n2
  n2 --> n3
  n3 --> n4
  n4 --> n5
  n5 --> n6
  n6 --> n7
  n7 --> n8
  n8 --> n9
  n9 --> n10
  n10 --> n11
````

**核心概念**——重启策略：
- **one-for-one**：只重启失败的那个（独立任务）
- **one-for-all**：一个失败，全部重启（强依赖任务组）
- **rest-for-one**：失败的 + 它之后的全重启（有序依赖链）

**本质**：把"容错"和"业务逻辑"分离。Worker 只做业务，Supervisor 负责容错。

**经典实现**：Erlang/OTP 的 Supervisor Tree，整个系统就是一棵监督树。

**AI 映射**：
- Multi-Agent 的 Supervisor（主 Agent 监控子 Agent，失败了重新派发）
- 长时间任务的心跳检测 + 自动恢复
- ReAct Agent 的外层包一个 Supervisor（超时 / 工具调用失败 → 重试策略）
- 你们的军团架构（J.A.R.V.I.S. 作为 Supervisor，各专业 Agent 是 Worker）

---

## 5. 蜂群模式（Swarm）⭐

**问题**：任务可以并行处理，有大量同质的 Agent，希望无中心化自组织完成任务。

````mermaid
flowchart TD
  n1["任务池"]
  n2["[任务1][任务2][任务3][任务4][任务5][任务6]..."]
  n3["↓       ↓       ↓       ↓"]
  n4["工蜂A   工蜂B   工蜂C   工蜂D   （各自认领，并行处理）"]
  n5["↓       ↓"]
  n6["结果汇聚（Aggregator）"]
  n1 --> n2
  n2 --> n3
  n3 --> n4
  n4 --> n5
  n5 --> n6
````

**特点**：
- **无中心**：没有 Supervisor 分配任务，每个 Agent 自主认领
- **同质**：所有 Agent 能力相同（或相近）
- **弹性**：加减 Agent 不影响系统运行
- **涌现**：整体智能高于个体之和（蚁群算法的本质）

**两种蜂群**：
- **竞争式**：Agent 抢任务（谁先拿到谁做）
- **分布式共识**：Agent 投票/协商（去中心化决策）

**vs 监督者**：
````mermaid
flowchart TD
  n1["监督者：有\"老大\"，老大分配任务，管控子 Agent"]
  n2["蜂群：  没有老大，Agent 平等，自主协调"]
  n1 --> n2
````

**AI 映射**：
- OpenAI Swarm（早期开源框架）的设计理念
- 大规模并行任务（FARS 同时跑多个研究课题）
- 分布式爬取、并行评测、大规模数据处理

---

## 6. 主从模式（Master-Worker）

**问题**：一个主节点负责任务分解和结果汇聚，多个从节点负责执行。

````mermaid
flowchart TD
  n1["主节点（Master）"]
  n2["├─ 任务分解（Divide）"]
  n3["├─ 分发给 Worker"]
  n4["└─ 结果汇聚（Aggregate）"]
  n5["从节点（Worker）× N"]
  n6["└─ 执行子任务，返回结果"]
  n1 --> n2
  n2 --> n3
  n3 --> n4
  n4 --> n5
  n5 --> n6
````

**vs 蜂群**：Master-Worker 有明确的层级（主从），蜂群是扁平的。
**vs 监督者**：Master 关注的是**任务执行效率**（分发+汇聚），Supervisor 关注的是**容错和可靠性**（失败重启）。

**AI 映射**：
- 并行推理（一个请求拆成多个子查询，各 Worker 并行处理，合并结果）
- RAGEN 的 rollout 并发（一个 prompt，N 个 Worker 各采样一条轨迹）
- MapReduce 的本质就是 Master-Worker

---

## 模式选型决策树

````mermaid
flowchart TD
  n1["新 AI 协作系统，选哪个模式？"]
  n2["流程固定吗？"]
  n3["├─ 是  →  管道-过滤器"]
  n4["└─ 否  →  需要多个专家协同渐进求解吗？"]
  n5["├─ 是  →  黑板模式"]
  n6["└─ 否  →  有中心协调者吗？"]
  n7["├─ 有  →  需要容错/重启吗？"]
  n8["│           ├─ 是  →  监督者模式"]
  n9["│           └─ 否  →  中介者 / Master-Worker"]
  n10["└─ 没有  →  任务同质可并行吗？"]
  n11["├─ 是  →  蜂群模式"]
  n12["└─ 否  →  发布订阅（事件驱动）"]
  n1 --> n2
  n2 --> n3
  n3 --> n4
  n4 --> n5
  n5 --> n6
  n6 --> n7
  n7 --> n8
  n8 --> n9
  n9 --> n10
  n10 --> n11
  n11 --> n12
````

---

## 模式组合实例：你们的军团架构

````mermaid
flowchart TD
  n1["用户消息"]
  n2["↓"]
  n3["[发布订阅]  事件广播到总线"]
  n4["↓"]
  n5["[外观模式]  J.A.R.V.I.S. 作为统一入口"]
  n6["↓"]
  n7["[监督者模式]  J.A.R.V.I.S. 监控各 Agent 健康状态"]
  n8["├─→ [策略模式]  动态选择哪个 Agent 处理"]
  n9["├─→ Scholar（研究）"]
  n10["├─→ Dobby（数据）"]
  n11["├─→ 贾维斯（执行）"]
  n12["└─→ ..."]
  n13["↓"]
  n14["[黑板模式]  共享工作区（bulletin.md / shared/）"]
  n15["↓"]
  n16["[管道模式]  心跳：读状态→执行任务→写日志→发通知"]
  n1 --> n2
  n2 --> n3
  n3 --> n4
  n4 --> n5
  n5 --> n6
  n6 --> n7
  n7 --> n8
  n8 --> n9
  n9 --> n10
  n10 --> n11
  n11 --> n12
  n12 --> n13
  n13 --> n14
  n14 --> n15
  n15 --> n16
````

---

## 核心对比总结

| 模式 | 中心化程度 | 流程固定 | 容错 | 适合任务类型 |
|------|---|---|---|---|
| 管道 | 无中心（顺序） | ✅ 固定 | ❌ | 数据流水线 |
| 黑板 | 弱中心（控制器） | ❌ 动态 | ✅ | 复杂问题协同求解 |
| 发布订阅 | 无中心（总线） | ❌ | ✅ | 事件驱动系统 |
| 监督者 | 强中心 | 视情况 | ✅✅ | 高可靠性任务 |
| 蜂群 | 无中心 | ❌ | ✅ | 大规模同质并行 |
| 主从 | 强中心 | ✅ | 中 | 可分解的大任务 |
