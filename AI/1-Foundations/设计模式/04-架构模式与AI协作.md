---
title: 架构模式与 AI 协作
tags: [design-pattern, architecture, ai-collaboration, multi-agent]
date: 2026-02-28
---

# 架构模式与 AI 协作

> 这是老板最关心的部分。
> GoF 模式解决的是代码级设计问题，架构模式解决的是**系统级协作问题**。
> 对 AI Agent 系统来说，这些模式直接映射到真实的系统设计选择。

---

## 1. 管道-过滤器（Pipeline-Filter）⭐

**问题**：数据需要经过一系列处理步骤，每步独立、可替换、可组合。

```
输入  →  [过滤器A]  →  [过滤器B]  →  [过滤器C]  →  输出
          清洗          ��换          格式化

关键特性：
- 每个过滤器只知道自己的输入和输出格式
- 过滤器之间通过"管道"传递数据
- 可以任意组合、重排、替换某一段
```

**本质**：把复杂处理流程拆成独立可组合的小步骤。

**两种变体**：
- **线性管道**：A → B → C，严格串行
- **分支管道**：A → (B1 + B2 并行) → C（Fan-out / Fan-in）

**AI 映射**：
- RAG 管道：Query → 检索 → Rerank → 截断 → 生成 → 后处理
- 数据预处理管道：原始文档 → 清洗 → 分块 → 向量化 → 入库
- FARS 的四阶段：Ideation → Planning → Experiment → Writing
- LangChain Chain 本质是管道模式

**适合场景**：流程固定、步骤明确、数据单向流动。

---

## 2. 黑板模式（Blackboard）⭐

**问题**：多个专家（Agent）处理同一个复杂问题，没有人能单独解决，需要协同——但各专家擅长领域不同，不知道该何时介入。

```
                    ┌──────────────┐
                    │   黑板（共享）  │
                    │  问题状态      │
                    │  中间结果      │
                    │  当前假设      │
                    └──────┬───────┘
                           │ 读/写
        ┌──────────────────┼──────────────────┐
        ↓                  ↓                  ↓
   [专家A]             [专家B]             [专家C]
   语法分析            语义理解            背景知识
   
   控制组件：监控黑板状态，决定激活哪个专家
```

**本质**：
- **黑板**：所有人共享的工作区（状态 + 中间结果）
- **专家（知识源）**：独立的处理单元，监视黑板、贡献专业判断
- **控制组件**：决定谁下一步发言（可以是规则，也可以是竞价）

**核心特点**：
- 专家之间**不直接通信**，只通过黑板间接协作
- 没有固定流程，哪个专家"有话说"就写到黑板上
- 适合**渐进式求解**——问题答案不是一步算出来的，是多轮迭代收敛的

**经典案例**：HEARSAY-II 语音识别系统（1970s），是黑板模式的发明场景。

**AI 映射（你们刚上线的）**：
- 多 Agent 共享一个结构化的"工作区"（共享内存/数据库）
- 不同 Agent 负责不同维度的分析，结果都写入黑板
- 一个协调 Agent（或规则引擎）决定当前激活哪个 Agent
- 适合：复杂问题求解、多轮迭代分析、需要多个专业视角综合的场景

**vs 管道**：管道流程固定（A→B→C），黑板流程动态（谁有贡献谁写）。

---

## 3. 发布-订阅（Pub/Sub）⭐

**问题**：事件的发布方不应该知道谁在监听，订阅方不应该知道谁在发布——完全解耦。

```
发布方A  ──→┐
发布方B  ──→│  消息总线 / 事件队列  ──→ 订阅方X（订阅了主题1）
发布方C  ──→┘  (Topic 1, 2, 3)    ──→ 订阅方Y（订阅了主题1+2）
                                   ──→ 订阅方Z（订阅了主题2+3）
```

**vs 观察者**：
```
观察者模式：Subject 直接持有观察者列表（知道对方是谁）
Pub/Sub：   发布方和订阅方都只认识"总线"（完全匿名）
```

**AI 映射**：
- 事件驱动的 Agent 协调：用户消息 → 发布到总线 → 意图识别/记忆检索/工具准备 并发订阅
- 异步任务通知：长时间任务完成 → 发布事件 → 通知相关等待方
- 多 Agent 松耦合协作（新加 Agent 只需订阅相关 topic，不改现有代码）

---

## 4. 监督者模式（Supervisor）⭐

**问题**：子进程/子任务失败了，需要有人监控并决定重启、忽略还是升级错误。

```
                  ┌─────────────────┐
                  │    Supervisor   │
                  │  监控 + 决策策略  │
                  └────────┬────────┘
            ┌──────────────┼──────────────┐
            ↓              ↓              ↓
         Worker A       Worker B       Worker C
         （正常）        （失败）        （正常）
                           │
                    Supervisor 收到失败信号
                    决策：重启 / 换一个 / 升级
```

**核心概念**——重启策略：
- **one-for-one**：只重启失败的那个（独立任务）
- **one-for-all**：一个失败，全部重启（强依赖任务组）
- **rest-for-one**：失败的 + 它之后的全重启（有序依赖链）

**本质**：把"容错"和"业务逻辑"分离。Worker 只做业务，Supervisor 负责容错。

**经典实现**：Erlang/OTP 的 Supervisor Tree，整个系统就是一棵监督树。

**AI 映射**：
- Multi-Agent 的 Supervisor（主 Agent 监控子 Agent，失败了重新派发）
- 长时间任务的心跳检测 + 自动恢复
- ReAct Agent 的外层包一个 Supervisor（超时 / 工具调用失败 → 重试策略）
- 你们的军团架构（J.A.R.V.I.S. 作为 Supervisor，各专业 Agent 是 Worker）

---

## 5. 蜂群模式（Swarm）⭐

**问题**：任务可以并行处理，有大量同质的 Agent，希望无中心化自组织完成任务。

```
任务池
[任务1][任务2][任务3][任务4][任务5][任务6]...
    ↓       ↓       ↓       ↓
  工蜂A   工蜂B   工蜂C   工蜂D   （各自认领，并行处理）
    ↓       ↓
  结果汇聚（Aggregator）
```

**特点**：
- **无中心**：没有 Supervisor 分配任务，每个 Agent 自主认领
- **同质**：所有 Agent 能力相同（或相近）
- **弹性**：加减 Agent 不影响系统运行
- **涌现**：整体智能高于个体之和（蚁群算法的本质）

**两种蜂群**：
- **竞争式**：Agent 抢任务（谁先拿到谁做）
- **分布式共识**：Agent 投票/协商（去中心化决策）

**vs 监督者**：
```
监督者：有"老大"，老大分配任务，管控子 Agent
蜂群：  没有老大，Agent 平等，自主协调
```

**AI 映射**：
- OpenAI Swarm（早期开源框架）的设计理念
- 大规模并行任务（FARS 同时跑多个研究课题）
- 分布式爬取、并行评测、大规模数据处理

---

## 6. 主从模式（Master-Worker）

**问题**：一个主节点负责任务分解和结果汇聚，多个从节点负责执行。

```
主节点（Master）
  ├─ 任务分解（Divide）
  ├─ 分发给 Worker
  └─ 结果汇聚（Aggregate）

从节点（Worker）× N
  └─ 执行子任务，返回结果
```

**vs 蜂群**：Master-Worker 有明确的层级（主从），蜂群是扁平的。
**vs 监督者**：Master 关注的是**任务执行效率**（分发+汇聚），Supervisor 关注的是**容错和可靠性**（失败重启）。

**AI 映射**：
- 并行推理（一个请求拆成多个子查询，各 Worker 并行处理，合并结果）
- RAGEN 的 rollout 并发（一个 prompt，N 个 Worker 各采样一条轨迹）
- MapReduce 的本质就是 Master-Worker

---

## 模式选型决策树

```
新 AI 协作系统，选哪个模式？

流程固定吗？
  ├─ 是  →  管道-过滤器
  └─ 否  →  需要多个专家协同渐进求解吗？
              ├─ 是  →  黑板模式
              └─ 否  →  有中心协调者吗？
                          ├─ 有  →  需要容错/重启吗？
                          │           ├─ 是  →  监督者模式
                          │           └─ 否  →  中介者 / Master-Worker
                          └─ 没有  →  任务同质可并行吗？
                                        ├─ 是  →  蜂群模式
                                        └─ 否  →  发布订阅（事件驱动）
```

---

## 模式组合实例：你们的军团架构

```
用户消息
    ↓
[发布订阅]  事件广播到总线
    ↓
[外观模式]  J.A.R.V.I.S. 作为统一入口
    ↓
[监督者模式]  J.A.R.V.I.S. 监控各 Agent 健康状态
    ├─→ [策略模式]  动态选择哪个 Agent 处理
    ├─→ Scholar（研究）
    ├─→ Dobby（数据）
    ├─→ 贾维斯（执行）
    └─→ ...
         ↓
    [黑板模式]  共享工作区（bulletin.md / shared/）
         ↓
    [管道模式]  心跳：读状态→执行任务→写日志→发通知
```

---

## 核心对比总结

| 模式 | 中心化程度 | 流程固定 | 容错 | 适合任务类型 |
|------|---|---|---|---|
| 管道 | 无中心（顺序） | ✅ 固定 | ❌ | 数据流水线 |
| 黑板 | 弱中心（控制器） | ❌ 动态 | ✅ | 复杂问题协同求解 |
| 发布订阅 | 无中心（总线） | ❌ | ✅ | 事件驱动系统 |
| 监督者 | 强中心 | 视情况 | ✅✅ | 高可靠性任务 |
| 蜂群 | 无中心 | ❌ | ✅ | 大规模同质并行 |
| 主从 | 强中心 | ✅ | 中 | 可分解的大任务 |
