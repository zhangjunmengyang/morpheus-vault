---
title: 行为型模式（GoF）
tags: [design-pattern, behavioral]
date: 2026-02-28
---

# 行为型模式（GoF）

> 核心问题：**对象之间如何分工协作、如何传递消息**。
> 一句话：定义"谁做什么、怎么配合"的规则。

---

## 1. 观察者（Observer）⭐

**问题**：一个对象状态变化，需要通知一批依赖它的对象——但不想让它们紧耦合。

```
被观察者（Subject）
  ├─ register(观察者A)
  ├─ register(观察者B)
  └─ notify()
       ├─→ 观察者A.update()
       └─→ 观察者B.update()

Subject 不知道观察者是谁，只管广播
```

**本质**：一对多依赖关系，状态变化自动通知。
**vs 发布订阅**：观察者模式里 Subject 直接持有观察者列表（仍有耦合）；发布订阅中间多了一个消息总线，完全解耦。

**AI 映射**：
- 工具调用完成 → 通知等待结果的 Agent
- 模型推理完成 → 触发下游记忆写入、日志记录、UI 更新
- 贾维斯的事件驱动：一个用户消息到来 → 触发意图识别、历史检索、响应生成等多个并发动作

---

## 2. 策略（Strategy）⭐

**问题**：同一件事有多种做法，希望运行时灵活切换，而不是写一堆 if-else。

```
Context（上下文）
  └─ strategy: Strategy接口
       ├─ StrategyA（算法A）
       ├─ StrategyB（算法B）
       └─ StrategyC（算法C）

切换策略 = 换一个实现，Context 代码不变
```

**本质**：把"算法"封装成可替换的对象。
**AI 映射**：
- 检索策略（BM25 / 向量检索 / 混合检索）运行时切换
- Reward 计算策略（规则 / RM / LLM-as-Judge）
- 路由策略（关键词路由 / 语义路由 / 模型路由）
- RAGEN 里的 policy optimization 策略（PPO / GRPO / REINFORCE）可插拔

---

## 3. 责任链（Chain of Responsibility）

**问题**：一个请求需要经过多个处理者，每个处理者决定是否处理、是否继续传递。

```
请求  →  处理者A  →  处理者B  →  处理者C  →  (未处理)
          │              │
        处理并停止    转发给下一个
```

**本质**：处理者形成链，请求沿链传递直到被处理。
**vs 管道**：责任链里每个节点可以决定是否继续（可以拦截）；管道里每个节点都必须处理并传递。

**AI 映射**：
- 内容安全检查链：违禁词过滤 → 语义审核 → 人工复核
- 权限校验链：本地缓存权限 → 数据库权限 → SSO 验证
- Agent 降级链：Claude → GPT-4 → 本地模型（前一个失败才到下一个）

---

## 4. 状态（State）

**问题**：对象在不同状态下行为差异巨大，写一堆 if-else 判断当前状态很难维护。

```
Context 持有当前 State 对象
  State: Idle    → action() 执行空闲行为
  State: Running → action() 执行运行行为
  State: Error   → action() 执行错误处理

状态切换 = 替换 Context 持有的 State 对象
```

**本质**：把状态转移逻辑封装在 State 对象里，Context 委托给当前 State 执行。
**AI 映射**：
- Agent 的状态机（Thinking → Tool_Calling → Waiting → Responding）
- 对话管理状态（Opening → Intent_Clarifying → Executing → Confirming）
- OpenAI Run 对象的状态（queued → in_progress → requires_action → completed）

---

## 5. 命令（Command）

**问题**：想把一个操作（请求）封装成对象，支持撤销、队列、延迟执行。

```
调用方  →  Command对象（封装操作）  →  执行者
                │
           支持：
           ├─ execute()
           ├─ undo()       ← 撤销
           └─ 入队列       ← 延迟执行
```

**本质**：把"做什么"封装成一等公民对象，解耦"发出请求"和"执行请求"。
**AI 映射**：
- 工具调用封装为 Command（支持重试、撤销、异步执行）
- 批量任务队列（把 Agent 任务封装成 Command 放入 Job Queue）
- Undo/Redo 操作历史（代码编辑 Agent 的撤销）

---

## 6. 中介者（Mediator）

**问题**：多个对象互相通信，两两之间都有连线，关系复杂如蜘蛛网——引入一个中间人统一协调。

```
没有中介者：
A ←→ B ←→ C ←→ D（N*(N-1)/2 条连线）

有中介者：
A → 中介者 ← B
C → 中介者 ← D
（所有连线收敛到中介者，N 条连线）
```

**本质**：用一个中心节点替代网状关系，降低耦合。
**vs 外观（Facade）**：外观是单向的（外部→内部），中介者是双向的（各组件通过中介者互通）。

**AI 映射**：
- Multi-Agent 的 Orchestrator（各 Agent 不直接通信，通过 Orchestrator 协调）
- 事件总线（各 Agent 向总线发消息，不需要知道谁在监听）
- Supervisor 模式的核心就是 Mediator

---

## 7. 模板方法（Template Method）

**问题**：一个算法的骨架固定，但其中某些步骤因子类而异。

```
抽象类定义骨架：
  step1()（固定）→ step2()（子类实现）→ step3()（固定）→ step4()（子类实现）

子类只覆盖可变的步骤，骨架不变
```

**本质**：父类定义流程，子类填充细节。
**AI 映射**：
- ReAct 循环（Think → Act → Observe 骨架固定，具体 Tool 调用子类实现）
- 论文写作流程（FARS 的四阶段骨架固定，各阶段内容可替换）

---

## 8. 备忘录（Memento）

**问题**：需要保存对象状态并在之后恢复，但不暴露内部细节。

```
Originator（原对象）
  └─ save()  →  Memento（快照）
  └─ restore(memento)  ←  从快照恢复
```

**本质**：对象自己创建快照，快照是不透明的（外部不能读内部状态）。
**AI 映射**：
- Agent 上下文快照（保存推理中间状态，支持回滚）
- Conversation Checkpoint（长对话的状态保存与恢复）

---

## 9. 迭代器（Iterator）

**问题**：遍历一个集合，但不想暴露集合内部结构。

```
集合  →  iterator()  →  Iterator
                         ├─ next()
                         ├─ hasNext()
                         └─ 调用方不知道集合是数组/链表/树
```

**本质**：统一遍历接口，隐藏内部数据结构。
**AI 映射**：流式输出（Streaming）本质是迭代器——调用方通过 iterator 逐 token 读取，不关心模型内部如何生成。

---

## 10. 访问者（Visitor）

**问题**：有一批稳定的对象结构，但需要对它们频繁添加新操作，不想每次都改这些对象。

```
对象结构（稳定）          操作（频繁变化）
  节点A  ←─ accept(v) ─── Visitor.visitA(节点A)
  节点B  ←─ accept(v) ─── Visitor.visitB(节点B)

新加操作 = 新加一个 Visitor，不改节点
```

**本质**：把操作和数据结构分离，操作可以独立扩展。
**AI 映射**：对 AST / 知识图谱节点做多种分析（代码检查、安全扫描、文档生成），每种分析是一个 Visitor。

---

## 行为型模式对比

| 模式 | 核心意图 | AI 场景关联度 |
|------|---|---|
| 观察者 | 状态变化广播通知 | ⭐⭐⭐ 事件驱动核心 |
| 策略 | 算法可替换 | ⭐⭐⭐ 路由/检索/优化策略 |
| 责任链 | 请求沿链传递 | ⭐⭐ 安全过滤/降级 |
| 状态 | 状态切换行为变化 | ⭐⭐⭐ Agent 状态机 |
| 命令 | 操作封装为对象 | ⭐⭐ 工具调用队列 |
| 中介者 | 集中协调多组件 | ⭐⭐⭐ Orchestrator 核心 |
| 模板方法 | 固定流程，可变步骤 | ⭐⭐ ReAct 骨架 |
| 备忘录 | 状态快照与恢复 | ⭐⭐ Checkpoint |
| 迭代器 | 统一遍历接口 | ⭐ Streaming 输出 |
| 访问者 | 操作与结构分离 | ⭐ 代码分析工具 |
