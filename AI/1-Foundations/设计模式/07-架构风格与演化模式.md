---
title: 架构风格与演化模式
tags: [design-pattern, architecture-style, DDD, evolution, system-design]
date: 2026-02-28
---

# 架构风格与演化模式

> 前六篇讲的是"零件怎么组合"，这篇讲"整个系统长什么形状"。
> 架构风格是**宏观的系统组织方式**，它决定了团队如何分工、系统如何扩展、技术债如何偿还。
> 对 AI 应用工程师来说，这层理解决定了你能不能和顶级架构师对话。

---

## 一、经典架构风格谱系

### 1. 分层架构（Layered / N-Tier）

**最常见**，几乎所有系统的起点。

````mermaid
flowchart TD
  n1["┌─────────────────────────┐"]
  n2["│     表现层 Presentation  │  ← 用户看到的（API / UI）"]
  n3["├─────────────────────────┤"]
  n4["│     业务层 Business      │  ← 核心逻辑"]
  n5["├─────────────────────────┤"]
  n6["│     持久层 Persistence   │  ← 数据访问"]
  n7["├─────────────────────────┤"]
  n8["│     数据库 Database      │  ← 存储"]
  n9["└─────────────────────────┘"]
  n10["依赖方向：只能向下，不能跨层"]
  n1 --> n2
  n2 --> n3
  n3 --> n4
  n4 --> n5
  n5 --> n6
  n6 --> n7
  n7 --> n8
  n8 --> n9
  n9 --> n10
````

**优点**：简单、直观、容易理解。
**缺点**：每层变化都可能影响相邻层；大系统后"大泥球"（Big Ball of Mud）风险。
**AI 映射**：最简单的 LLM 应用就是分层架构（API层→Prompt层→模型层→数据层）。

---

### 2. 六边形架构（Hexagonal / Ports & Adapters）⭐

**问题**：分层架构里，核心业务逻辑依赖了外部系统（数据库、API）——测试困难，换技术栈很痛。

````mermaid
flowchart TD
  n1["外部系统A（数据库）"]
  n2["↕ Adapter"]
  n3["外部系统B ─── Port ───→ 【核心领域逻辑】 ←─── Port ─── 外部系统C（第三方API）"]
  n4["（UI/API）  ↕ Adapter"]
  n5["↕"]
  n6["外部系统D（消息队列）"]
  n1 --> n2
  n2 --> n3
  n3 --> n4
  n4 --> n5
  n5 --> n6
````

**核心思想**：
- **核心领域**：只包含业务规则，不知道任何外部系统的存在
- **Port**：核心领域定义的接口（我需要"能存数据的东西"）
- **Adapter**：具体实现（MySQL Adapter / Redis Adapter / Mock Adapter）

**优点**：核心逻辑可独立测试，外部系统可随时替换。
**AI 映射**：
- 核心 Agent 逻辑 ← Port → LLM Adapter（换 GPT-4 还是 Claude 只改 Adapter）
- 核心 Agent 逻辑 ← Port → Memory Adapter（换向量库不影响核心逻辑）
- 这是设计**可测试、可替换**的 AI 应用的正确方式

---

### 3. 事件驱动架构（Event-Driven Architecture，EDA）⭐

**问题**：组件之间直接调用 → 强耦合，一个挂了影响所有人。

````mermaid
flowchart TD
  n1["传统请求-响应："]
  n2["A 调用 B → B 调用 C → C 调用 D（同步链，任何一环慢都卡住）"]
  n3["事件驱动："]
  n4["A 发布事件 \"订单创建\""]
  n5["↓"]
  n6["事件总线"]
  n7["├─→ B 订阅并处理（异步）"]
  n8["├─→ C 订阅并处理（异步）"]
  n9["└─→ D 订阅并处理（异步）"]
  n10["A 不知道谁在监听，不等待响应"]
  n1 --> n2
  n2 --> n3
  n3 --> n4
  n4 --> n5
  n5 --> n6
  n6 --> n7
  n7 --> n8
  n8 --> n9
  n9 --> n10
````

**三个核心组件**：
- **事件生产者**：发布领域事件（不关心谁处理）
- **事件总线**：Kafka / RabbitMQ / EventBridge
- **事件消费者**：订阅感兴趣的事件（不知道谁发的）

**两种子风格**：
- **Event Notification**：只通知"发生了什么"（消费者自己去查详情）
- **Event-Carried State Transfer**：事件携带完整数据（消费者不需要回查）

**AI 映射**：
- 用户发消息 → 事件 → 触发意图识别 / 记忆检索 / 工具准备（并发）
- Agent 完成工具调用 → 事件 → 触发结果处理 / 日志写入 / 下一步规划
- 贾维斯军团的整体协作骨架

---

### 4. 微核架构（Microkernel / Plugin）

**问题**：系统核心稳定，但功能需要频繁扩展——不想每次都改核心代码。

````mermaid
flowchart TD
  n1["┌──────────────────────────────────────────────┐"]
  n2["│            微核（Core System）                 │"]
  n3["│  最小化核心功能 + 插件注册表 + 插件通信协议    │"]
  n4["└──────────┬───────────────────────────────────┘"]
  n5["│"]
  n6["┌─────┼─────┐"]
  n7["↓     ↓     ↓"]
  n8["插件A  插件B  插件C"]
  n9["（独立开发，独立部署）"]
  n1 --> n2
  n2 --> n3
  n3 --> n4
  n4 --> n5
  n5 --> n6
  n6 --> n7
  n7 --> n8
  n8 --> n9
````

**经典案例**：
- Eclipse / VS Code（核心极小，功能全靠插件）
- Jenkins（流水线核心 + 无数插件）
- Chrome（浏览器内核 + Extension）

**AI 映射**：
- Agent 工具系统（核心 Agent + Tool 插件）
- MCP 协议的本质：给 Agent 设计了一套"插件标准"，任何工具都能接入
- LangChain 的设计思路：核心链 + 可插拔组件

---

### 5. 领域驱动设计（DDD，Domain-Driven Design）⭐

**不是一个模式，是一套方法论**，但 AI 应用工程师必须了解其中几个核心概念：

#### 限界上下文（Bounded Context）

````mermaid
flowchart TD
  n1["\"用户\"这个词在不同上下文含义不同："]
  n2["订单上下文         用户中心上下文       推荐上下文"]
  n3["User = {          User = {           User = {"]
  n4["orderId,          userId,             userId,"]
  n5["address,          name,               preferences,"]
  n6["paymentInfo       email               browsHistory"]
  n7["}                 }                  }"]
  n8["每个上下文内部用自己的语言，上下文之间通过明确的接口通信"]
  n1 --> n2
  n2 --> n3
  n3 --> n4
  n4 --> n5
  n5 --> n6
  n6 --> n7
  n7 --> n8
````

**AI 映射**：
- Scholar Agent 的"论文"和 Dobby Agent 的"数据"是不同上下文，不能混用同一个数据模型
- 每个 Agent 是一个独立的限界上下文，有自己的语言和职责边界

#### 防腐层（Anti-Corruption Layer，ACL）

````mermaid
flowchart TD
  n1["旧系统（混乱的数据模型）"]
  n2["↕"]
  n3["【防腐层：翻译 + 过滤】"]
  n4["↕"]
  n5["新系统（干净的领域模型）"]
  n6["防腐层保护新系统不被旧系统的概念污染"]
  n1 --> n2
  n2 --> n3
  n3 --> n4
  n4 --> n5
  n5 --> n6
````

**AI 映射**：
- 接入遗留数据库时，防腐层把混乱的数据库字段映射成干净的 Agent 可理解的结构
- LLM 返回的非结构化文本 → 防腐层解析 → 结构化数据

#### 聚合根（Aggregate Root）

````mermaid
flowchart TD
  n1["订单（聚合根）"]
  n2["├─ 订单项1"]
  n3["├─ 订单项2"]
  n4["└─ 配送地址"]
  n5["外部只能通过\"订单\"操作，不能直接改\"订单项\""]
  n6["聚合根保证内部一致性"]
  n1 --> n2
  n2 --> n3
  n3 --> n4
  n4 --> n5
  n5 --> n6
````

**AI 映射**：对话 Session 是聚合根（所有操作通过 Session 入口，保证状态一致性）。

---

## 二、系统演化模式

### 6. 绞杀者无花果（Strangler Fig）⭐

**问题**：有一个运行中的遗留系统，需要逐步替换，但不能停机、不能全量重写。

````mermaid
flowchart TD
  n1["阶段1：新老系统并存，路由层分流部分流量到新系统"]
  n2["用户请求 → 路由层 → 80% 旧系统 / 20% 新系统"]
  n3["阶段2：逐步迁移功能模块，调大新系统比例"]
  n4["用户请求 → 路由层 → 20% 旧系统 / 80% 新系统"]
  n5["阶段3：旧系统完全被\"绞死\"，全量切换"]
  n6["用户请求 → 路由层 → 100% 新系统（旧系统退役）"]
  n1 --> n2
  n2 --> n3
  n3 --> n4
  n4 --> n5
  n5 --> n6
````

**名字来源**：热带雨林里的绞杀榕，从宿主树外部生长，最终完全替代宿主。

**AI 映射**：
- 用 AI Agent 逐步替换传统规则引擎（不停机，灰度放量）
- 老的 NL2SQL Workflow → 逐步迁移到 Agent 方式（你们美团的演进路线）
- 旧的数仓取数 API → 逐步被 LLM 取数 Agent 替代

---

### 7. 特性开关（Feature Toggle / Feature Flag）

**问题**：代码已部署，但想控制哪些用户能看到新功能；想 A/B 测试；想快速回滚。

````mermaid
flowchart TD
  n1["if feature_flag(\"new_agent_v2\", user_id):"]
  n2["use_new_agent()"]
  n3["else:"]
  n4["use_old_agent()"]
  n5["开关存在配置中心，实时修改，无需重新部署"]
  n1 --> n2
  n2 --> n3
  n3 --> n4
  n4 --> n5
````

**四种类型**：
- **发布开关**：新功能灰度放量（5% → 20% → 100%）
- **实验开关**：A/B 测试（哪个 prompt 效果好）
- **运维开关**：紧急降级（线上问题，立即关掉某功能）
- **权限开关**：内测用户提前体验

**AI 映射**：
- Prompt 版本控制（新 prompt 只给 10% 用户，观察效果）
- 模型切换（新模型灰度上线）
- Agent 能力的灰度开放

---

### 8. 蓝绿部署（Blue-Green Deployment）

**问题**：新版本上线时，如何做到零停机，出问题立即回滚？

````mermaid
flowchart TD
  n1["蓝环境（当前生产）：v1.0  ← 100% 流量"]
  n2["绿环境（新版本）：  v2.0  ← 0% 流量（准备中）"]
  n3["切换："]
  n4["蓝环境：v1.0  ← 0% 流量（待机）"]
  n5["绿环境：v2.0  ← 100% 流量（上线）"]
  n6["回滚：切回蓝环境，秒级完成"]
  n1 --> n2
  n2 --> n3
  n3 --> n4
  n4 --> n5
  n5 --> n6
````

**AI 映射**：
- 新版 Agent 上线（新旧两套 Agent 并存，切流量验证）
- 新版 RAG 知识库更新（新旧知识库并存，切流量 A/B）

---

### 9. 金丝雀发布（Canary Release）

**问题**：蓝绿是全量切换，金丝雀是渐进式放量——先让少数用户用新版本，发现问题及时止损。

````mermaid
flowchart TD
  n1["全部用户 100%"]
  n2["├── 1% → 新版本（金丝雀）  ← 监控指标"]
  n3["└── 99% → 旧版本"]
  n4["观察指标正常 → 逐步扩大：5% → 10% → 50% → 100%"]
  n5["发现问题     → 立即回滚到 0%，损失极小"]
  n1 --> n2
  n2 --> n3
  n3 --> n4
  n4 --> n5
````

**名字来源**：矿工用金丝雀检测煤矿中的有毒气体——金丝雀先感知危险。

**AI 映射**：
- 新版 LLM 模型灰度（1% 流量先跑，看质量/成本/延迟）
- 新 Prompt 版本逐步放量

---

## 三、架构设计原则（SOLID & 扩展）

### SOLID 五原则

````mermaid
flowchart TD
  n1["S — Single Responsibility（单一职责）"]
  n2["一个类/模块只做一件事"]
  n3["AI映射：一个 Agent 只负责一种专业（Scholar专研究，Dobby专数据）"]
  n4["O — Open/Closed（开闭原则）"]
  n5["对扩展开放，对修改关闭"]
  n6["AI映射：新工具不改 Agent 核心，只加新 Adapter"]
  n7["L — Liskov Substitution（里氏替换）"]
  n8["子类可以替换父类而不破坏程序"]
  n9["AI映射：Claude 替换 GPT-4，不应该改上层逻辑（六边形架构保证这点）"]
  n10["I — Interface Segregation（接口隔离）"]
  n11["客户端不应依赖它不需要的接口"]
  n12["AI映射：工具接口细粒度设计，不要一个大接口包含所有工具"]
  n13["D — Dependency Inversion（依赖倒置）"]
  n14["高层不依赖低层，都依赖抽象"]
  n15["AI映射：Agent 依赖\"LLM 接口\"，不依赖\"OpenAI 具体实现\""]
  n1 --> n2
  n2 --> n3
  n3 --> n4
  n4 --> n5
  n5 --> n6
  n6 --> n7
  n7 --> n8
  n8 --> n9
  n9 --> n10
  n10 --> n11
  n11 --> n12
  n12 --> n13
  n13 --> n14
  n14 --> n15
````

### 三个扩展原则

**DRY（Don't Repeat Yourself）**：相同的 Prompt 片段、工具调用逻辑抽成复用组件。

**YAGNI（You Aren't Gonna Need It）**：不要提前设计用不到的功能。AI 系统过度设计是常见陷阱（先把 Agent 跑通，再优化架构）。

**关注点分离（Separation of Concerns）**：提示词逻辑 / 工具执行逻辑 / 记忆管理逻辑分开，不混在一起。

---

## 架构风格选型

````mermaid
flowchart TD
  n1["你的系统规模和阶段？"]
  n2["原型 / 小团队（< 5人）"]
  n3["→ 分层架构 + 单体部署（先跑通再说）"]
  n4["增长期（功能快速扩展）"]
  n5["→ 微核架构（插件化，易扩展）"]
  n6["→ 六边形架构（保持核心纯净，方便测试）"]
  n7["大规模（多团队并行开发）"]
  n8["→ 领域驱动设计（划清边界）"]
  n9["→ 事件驱动架构（解耦团队间依赖）"]
  n10["→ 微服务（独立部署）"]
  n11["遗留系统改造"]
  n12["→ 绞杀者模式（渐进替换）"]
  n13["→ 防腐层（保护新系统）"]
  n14["→ 特性开关（灰度迁移）"]
  n1 --> n2
  n2 --> n3
  n3 --> n4
  n4 --> n5
  n5 --> n6
  n6 --> n7
  n7 --> n8
  n8 --> n9
  n9 --> n10
  n10 --> n11
  n11 --> n12
  n12 --> n13
  n13 --> n14
````
