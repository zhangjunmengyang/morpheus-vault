---
title: 创建型模式
tags: [design-pattern, creational]
date: 2026-02-28
brief: GoF 6种创建型模式原理与AI映射：简单工厂/工厂方法/抽象工厂/建造者/单例/原型，核心是把"怎么造对象"和"怎么用对象"分开。
---

# 创建型模式

> 核心问题：**如何创建对象**，同时让调用方不依赖具体实现。
> 一句话：把"怎么造"和"怎么用"分开。

---

## 1. 简单工厂（Simple Factory）

**问题**：调用方需要某种对象，但不想关心具体怎么创建。

```mermaid
flowchart LR
    A[调用方] -->|type=A| F[工厂函数]
    F -->|返回| P1[对象A]
    F -->|返回| P2[对象B]
    F -->|返回| P3[对象C]
```

**本质**：一个 if-else 集中在工厂里，调用方只传类型名。
**缺点**：加新类型要改工厂——违反开闭原则。
**AI 映射**：根据任务类型路由到不同 Agent（`type="search"` → SearchAgent）。

---

## 2. 工厂方法（Factory Method）

**问题**：不同子类需要创建自己特定的对象，但创建逻辑各不相同。

```mermaid
classDiagram
    class Creator {
        <<abstract>>
        +create() Product
    }
    class CreatorA {
        +create() ProductA
    }
    class CreatorB {
        +create() ProductB
    }
    class Product {
        <<interface>>
    }
    Creator <|-- CreatorA
    Creator <|-- CreatorB
    Product <|.. ProductA
    Product <|.. ProductB
    CreatorA ..> ProductA
    CreatorB ..> ProductB
```

**本质**：把"创建"这个动作推迟到子类决定。
**vs 简单工厂**：增加新类型不改现有代码，只加新工厂。
**AI 映射**：不同平台/模型商用各自的 Agent 工厂创建 Agent 实例。

---

## 3. 抽象工厂（Abstract Factory）

**问题**：需要一族相关对象，保证"配套"（不能拿 A 风格的按钮配 B 风格的文本框）。

```mermaid
flowchart LR
    Client[调用方\n只认接口] --> AF{AbstractFactory\n接口}
    AF -->|实现| MacF[MacFactory]
    AF -->|实现| WinF[WinFactory]
    MacF -->|createButton| MB[Mac按钮]
    MacF -->|createInput| MI[Mac文本框]
    WinF -->|createButton| WB[Win按钮]
    WinF -->|createInput| WI[Win文本框]
```

**本质**：工厂方法的升级版，一次创建一整套风格一致的产品族。
**AI 映射**：为不同业务线提供"配套 Agent 套件"（搜索+写作+审核三件套，每条线定制一套）。

---

## 4. 建造者（Builder）

**问题**：对象构建过程很复杂，有很多可选参数，想一步一步配置。

```mermaid
sequenceDiagram
    participant C as 调用方
    participant B as Builder
    participant P as 产品

    C->>B: setName("小助手")
    C->>B: setMemory(true)
    C->>B: setTools([search])
    C->>B: setTemperature(0.7)
    C->>B: build()
    B->>P: 创建完整对象
    B-->>C: 返回 Product
```

**本质**：把"配置"和"最终构建"分离，支持链式调用。
**vs 工厂**：工厂关注"造哪种"，Builder 关注"怎么一步步造"。
**AI 映射**：Agent 初始化配置（工具列表、记忆类型、模型参数）。OpenAI Assistants API 就是 Builder 风格。

---

## 5. 单例（Singleton）

**问题**：某个对象全局只能有一个实例（配置中心、连接池、日志系统）。

```mermaid
flowchart LR
    A[第一次调用] -->|实例不存在→创建| I[唯一实例]
    B[第二次调用] -->|实例已存在→直接返回| I
    C[第三次调用] -->|实例已存在→直接返回| I
```

**本质**：构造函数私有化 + 静态持有自身引用。
**注意**：单例是最常被滥用的模式——不是"全局变量"的替代品。只有真正需要唯一性的场景才用。
**AI 映射**：全局的模型推理池、共享的 Token 计数器、系统级配置。

---

## 6. 原型（Prototype）

**问题**：创建一个新对象的成本很高，但新对象和已有对象差别不大——直接复制更快。

```mermaid
flowchart LR
    P[原型对象\n已配置完整] -->|clone| C1[副本1\n独立]
    P -->|clone| C2[副本2\n独立]
    C1 -->|小改动| C1M[用户A的实例]
    C2 -->|小改动| C2M[用户B的实例]
```

**本质**：复制比重新创建更高效。
**AI 映射**：Fork 一个已配置好的 Agent 实例，只改少数参数（同一个 Agent 模板，给不同用户各克隆一份）。

---

## 创建型模式对比

| 模式 | 解决的核心问题 | 关键词 |
|------|---|---|
| 简单工厂 | 集中创建逻辑 | 一个工厂，if-else |
| 工厂方法 | 子类决定创建 | 可扩展，不改原代码 |
| 抽象工厂 | 创建配套产品族 | 整套风格一致 |
| 建造者 | 复杂对象分步构建 | 链式配置 |
| 单例 | 全局唯一实例 | 只有一个 |
| 原型 | 复制比创建快 | clone |

---

## 选型决策树

```mermaid
flowchart TD
    Q1{需要创建什么？}
    Q1 -->|类型由参数决定，不关心细节| SF[简单工厂]
    Q1 -->|不同子类创建不同对象| FM[工厂方法]
    Q1 -->|需要一整套配套风格的对象| AF[抽象工厂]
    Q1 -->|对象构建步骤多/参数复杂| B[建造者]
    Q1 -->|全局只能有一个实例| S[单例]
    Q1 -->|复制已有对象更高效| P[原型]
```

## See Also
- [[02-结构型模式]] — 有了对象，怎么组合
- [[03-行为型模式-GoF]] — 对象之间如何协作
- [[00-设计模式总览MOC]] — 全局导览
