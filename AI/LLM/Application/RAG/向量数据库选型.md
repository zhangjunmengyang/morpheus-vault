---
tags: [向量数据库, RAG, 数据库选型, 向量索引, FAISS, Milvus, Qdrant, Pinecone, Chroma, Weaviate]
created: 2026-02-14
status: draft
---

# 向量数据库选型

向量数据库是 [[RAG]] 系统的核心组件，负责高效存储和检索高维向量。随着 LLM 应用的爆发，选择合适的向量数据库成为架构设计的关键决策。

## 主流向量数据库对比

### FAISS (Facebook AI Similarity Search)

**优势：**
- Meta 开发的成熟库，索引算法丰富
- 支持 GPU 加速，单机性能极强
- 内存占用可控，支持量化压缩

**劣势：**
- 单机版本，无原生分布式能力
- 需要额外开发元数据管理
- 持久化需要自行实现

```python
import faiss
import numpy as np

# 构建 IVF + PQ 索引
d = 768  # 向量维度
ncentroids = 100
code_size = 32

quantizer = faiss.IndexFlatIP(d)
index = faiss.IndexIVFPQ(quantizer, d, ncentroids, code_size, 8)

# 训练和添加数据
vectors = np.random.random((10000, d)).astype('float32')
index.train(vectors)
index.add(vectors)

# 搜索
query = np.random.random((1, d)).astype('float32')
scores, indices = index.search(query, k=10)
```

### Milvus

**优势：**
- 原生分布式架构，支持水平扩展
- 丰富的索引类型和距离度量
- 完善的元数据管理和 ACID 支持

**劣势：**
- 部署复杂，依赖组件多（etcd、MinIO等）
- 资源占用较大
- 社区版功能受限

### Qdrant

**优势：**
- Rust 实现，性能优异，内存安全
- 丰富的过滤功能，支持复杂查询
- 部署简单，单机也可用

**劣势：**
- 生态相对较新，企业采用案例较少
- 分布式能力相比 Milvus 较弱

### Pinecone

**优势：**
- 托管服务，运维成本低
- 性能稳定，延迟可控
- 集成度高，开发体验好

**劣势：**
- 费用昂贵，按量计费
- 数据存储在云端，隐私风险
- 功能相对简单

### Chroma

**优势：**
- 轻量级，适合原型开发
- 与 LangChain 深度集成
- 支持文档和向量一体存储

**劣势：**
- 性能和扩展性有限
- 企业级功能较少

### Weaviate

**优势：**
- 向量搜索 + 语义搜索结合
- GraphQL 接口，查询灵活
- 支持多模态数据

**劣势：**
- 学习曲线陡峭
- 性能相比专业向量库较弱

## 索引算法原理

### IVF (Inverted File Index)

将向量空间分割为多个区域（Voronoi cell），每个区域由一个质心代表。搜索时只需检查最近的几个质心对应的区域。

$$\text{IVF Search: } \arg\min_{i \in \text{nearest centroids}} \|q - v_i\|$$

**优势：** 搜索复杂度从 O(N) 降至 O(N/k)  
**劣势：** 质心数量需要调优，影响召回率

### HNSW (Hierarchical Navigable Small World)

基于图的多层索引结构，上层稀疏用于快速导航，下层密集保证精度。

```python
# HNSW 核心参数
M = 16          # 每层最大连接数
ef_construction = 200  # 构建时候选集大小
ef_search = 50  # 搜索时候选集大小

index = faiss.IndexHNSWFlat(d, M)
index.hnsw.efConstruction = ef_construction
index.hnsw.efSearch = ef_search
```

**优势：** 高召回率，搜索稳定  
**劣势：** 内存占用大，构建时间长

### PQ (Product Quantization)

将高维向量分割为子空间，每个子空间独立量化，大幅压缩存储空间。

$$\text{PQ}(x) = [q_1(u_1(x)), q_2(u_2(x)), ..., q_m(u_m(x))]$$

**压缩比：** 原始 float32 → uint8，压缩比 4:1

### ScaNN (Scalable Nearest Neighbors)

Google 开发的近似最近邻算法，结合了量化和图索引的优势。

## 性能维度分析

### 延迟 (Latency)

| 数据库 | P50延迟 | P99延迟 | 备注 |
|--------|---------|---------|------|
| FAISS | <1ms | <5ms | 内存索引 |
| Milvus | 2-10ms | 20-50ms | 网络+存储 |
| Qdrant | 1-5ms | 10-30ms | 高效实现 |
| Pinecone | 10-20ms | 50-100ms | 托管服务 |

### 吞吐量 (Throughput)

**FAISS：** 单机可达 10K+ QPS  
**Milvus：** 集群可达 100K+ QPS  
**Qdrant：** 单节点 5K+ QPS

### 召回率 (Recall)

召回率与索引参数、数据分布强相关：

```python
# 召回率计算示例
def calculate_recall(true_neighbors, predicted_neighbors, k):
    intersection = set(true_neighbors[:k]) & set(predicted_neighbors[:k])
    return len(intersection) / k
```

### 可扩展性

- **垂直扩展：** FAISS, Chroma
- **水平扩展：** Milvus, Qdrant (企业版)
- **托管扩展：** Pinecone

## 选型决策树

### 1. 数据量级决策

```
数据量 < 100万条
├─ 延迟要求 < 10ms → FAISS (内存)
└─ 其他需求 → Chroma

数据量 100万-1000万条  
├─ 有运维团队 → Milvus
└─ 轻量部署 → Qdrant

数据量 > 1000万条
├─ 预算充足 → Pinecone
└─ 自建方案 → Milvus 集群
```

### 2. 场景驱动决策

**原型开发：** Chroma + LangChain  
**生产 MVP：** Qdrant 单机  
**大规模生产：** Milvus 集群  
**企业托管：** Pinecone  
**极致性能：** FAISS + Redis

### 3. 成本考量

**开发成本：** Pinecone < Chroma < Qdrant < Milvus < FAISS  
**运维成本：** Pinecone < Qdrant < Chroma < Milvus < FAISS  
**使用成本：** FAISS < Qdrant < Milvus < Chroma < Pinecone

## 面试常见问题

### 1. FAISS 和 Milvus 的核心区别是什么？

**答案：**
FAISS 是单机向量搜索库，专注算法实现，性能极高但缺乏分布式能力和完整的数据管理功能。Milvus 是分布式向量数据库，提供完整的 CRUD、元数据管理、容错机制，但部署复杂度更高。

选择原则：数据量 < 千万级且对延迟要求极高选 FAISS；需要分布式、完整数据管理选 Milvus。

### 2. HNSW 和 IVF 索引的适用场景有何不同？

**答案：**
- **HNSW：** 适合高召回要求场景，如精确推荐系统。内存占用大但搜索稳定，适合读多写少场景
- **IVF：** 适合大规模数据和实时更新场景。内存友好，但需要调优质心数量平衡性能和召回率

实际选择：HNSW 用于质量优先场景，IVF 用于效率优先场景。

### 3. 向量数据库中如何处理冷热数据？

**答案：**
**分层存储策略：**
- 热数据：内存 HNSW 索引，毫秒级响应
- 温数据：SSD IVF 索引，10ms 级响应  
- 冷数据：对象存储 + 按需加载

**实现方案：**
```python
# 伪代码示例
if access_frequency > hot_threshold:
    store_in_memory_index(vector)
elif access_frequency > warm_threshold:
    store_in_ssd_index(vector)
else:
    store_in_object_storage(vector)
```

### 4. 如何评估向量数据库的索引质量？

**答案：**
**核心指标：**
- **Recall@K：** 召回率，准确性指标
- **QPS：** 查询吞吐量，性能指标  
- **Latency P99：** 延迟稳定性
- **Index Build Time：** 构建效率
- **Memory Usage：** 资源消耗

**评估方法：**
```python
# 基准测试框架
def benchmark_index(index, queries, ground_truth):
    latencies = []
    recalls = []
    
    for query in queries:
        start_time = time.time()
        results = index.search(query, k=10)
        latencies.append(time.time() - start_time)
        
        recall = calculate_recall(ground_truth[query], results)
        recalls.append(recall)
    
    return {
        'avg_latency': np.mean(latencies),
        'p99_latency': np.percentile(latencies, 99),
        'avg_recall': np.mean(recalls)
    }
```

### 5. 在生产环境中如何处理向量数据库的容灾和备份？

**答案：**
**多层容灾策略：**
1. **实时备份：** 主从同步，RPO < 1s
2. **异地容灾：** 跨区域副本，RTO < 30s
3. **数据备份：** 定期全量备份，保留30天

**具体实现：**
- **Milvus：** 使用 S3/MinIO 作为持久化层，支持增量备份
- **Qdrant：** 快照机制 + 副本集群
- **FAISS：** 定期序列化索引文件到对象存储

**故障恢复流程：**
```bash
# Milvus 恢复示例
./milvus-backup restore \
  --backup-name="backup_20240214" \
  --restore-cluster="production" \
  --force-overwrite=true
```

关键是建立 RTO/RPO 目标，选择合适的备份策略，并定期演练恢复流程。

---

相关笔记：[[RAG 系统架构设计]] | [[向量索引优化]] | [[Embedding 模型选择]]