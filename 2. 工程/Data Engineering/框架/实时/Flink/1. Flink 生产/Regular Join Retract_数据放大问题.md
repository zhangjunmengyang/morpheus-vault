# Regular Join Retract/数据放大问题

这种情况不太常见，平台似乎已经修复，可以作为了解原理学习使用

Flink Table API 或 SQL 中使用 **Aggregate + Regular Join** 的嵌套使用会导致数据错误和数据量放大

### 一、放大原理

1. 当 right 表出现更新时（R → R2），会下发两条数据（-R,+R2）
1. 对于这两条数据中的每一条，都会导致 Join 算子下发两条结果
- -R 到达时，下发一条 -L,R 表示撤回之前关联上的结果，同时由于是 left join 关联不上的时候应该补 null 下发，会再发一条 +L,null
- +R2 到达时， -L,null，再 +L,R2
1. 由此可见，右表更新了一条数据之后，Join 算子产生了两条回撤两条下发（-+-+），而不是预期中的一条回撤一条下发，中间两条（+-）其实可以互相抵消
1. 对于第二层 another 表的更新也是一样的情况，随着关联层级的增加，数据条数会呈指数级增长
**本质上是“****更新****”操作被拆分成了****一条删除+一条新增****，且这两条消息之间没有关联，被下游****当作两条独立的消息处理****了**

**影响：**

- 数据量逐级放大，最上游输入一条数据到最下游可能输出指数级的数据
- 过程数据会有短时间明显错误的结果，比如对于 Aggregate 等聚合计算，会导致聚合结果有短时间严重偏离正常值（例如 sum 出现明显的数据下降）
细节关联逻辑：

![image](assets/NwzYdhYZ9oyMUdxJqJQcfmVWnNl.png)

### 二、解决方案

#### 2.1、短期方案 mini-batch

**由于同一次更新操作下发的删除和新增两条消息发送时间非常接近**，对于聚合算子开启 mini-batch 后，大多数的更新操作会在一次聚合中天然被消除掉（聚合算子同 Key 只有一条输出结果），从而大幅降低数据放大问题的出现频率

#### 2.2、长期方案 平台支持 update 操作

对于更新的情况，使用 Change log 格式（包含删除和新增情况）下发，下游算子根据 Change log 进行处理。

看了下进展：高版本已经引入了 RowKind 来描述一条数据，目前有 INSERT、DELETE、UPDATE_BEFORE、UPDATE_AFTER 四个类型，但是在 Join 算子上还只用到了 INSERT、DELETE
