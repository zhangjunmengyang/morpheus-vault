# 4. Doris 生产

### Doris 高可用的原因

- **分区和分桶 **
用户通过指定分区和分桶列，能够完成分区分桶的裁剪，从而大大地减少查询的数据量。

- **多副本 **
每个Tablet的副本互为主备，每次查询的时候随机选择一个副本进行查询，但选择副本的时候会尽可能地使将每个节点上访问的副本数保持均匀。 选择的副本一定是最新的，因为至少会有一半以上的副本有最新数据，这是Doris的同步写入和事务所保证的。

- **PageCache**
Doris的存储层以64k的Page组织，每次读取Page的时候会从PageCache中查找，如果查找不到会从IO读取然后放入PageCache中。 PageCache的存在减少了IO的读取，对并发的提升十分重要。

PageCache会分成默认16个Shard，以减少锁竞争。

每个Shard下的PageCache由HandleTable和LRU Free链表组成

PageCache默认会占用内存的20%，当PageCache满了后会通过LRU Free链表换出没有使用的Page，如果全部都在被使用，集群的PageCache大小可能会超出。 每个PageHandle都会记录当前的引用，所有PageHandle都在HandleTable中记录。当引用为1时PageHandle会被加入LRU Free链表；当被lookup操作获取到时，引用+1，如果在LRU Free链表中会被移除。这保证了使用PageHandle的时候不会被其他查询释放内存。

- **FE 高可用**
元数据的每次更新，都首先写入到磁盘的日志文件中，然后再写到内存中，最后定期checkpoint到本地磁盘上。

相当于是一个纯内存的一个结构，也就是说所有的元数据都会缓存在内存之中，从而保证FE在宕机后能够快速恢复元数据，而且不丢失元数据。

Leader、follower和 observer它们三个构成一个可靠的服务，单机的节点故障的时候其实基本上三个就够了，因为FE节点毕竟它只存了一份元数据，它的压力不大，所以如果FE太多的时候它会去消耗机器资源，所以多数情况下三个就足够了，可以达到一个很高可用的元数据服务。一般是部署一个leader两个follower。

### 布隆过滤器

doris 默认是bloom filter，默认会开启布隆过滤器，如果因为其他因素（比如广播大表）导致时间过长，布隆过滤器也会超时，导致时间更长

### 谓词下推

谓词下推：生成查询计划后将查询限制条件下推至存储引擎，减少访问的数据量

在关系型数据库中，谓词是指SQL语句中的WHERE子句所使用的条件表达式，用于指示查询结果需要满足哪些限制条件。**谓词一般包括比较运算符、逻辑运算符、IN、LIKE、BETWEEN等条件表达式，可以用来查询具有一定条件的记录。谓词下推是指将SQL语句中的谓词尽可能地向数据源端推送，以减少数据传输量和计算负担，提高查询的性能。**在谓词下推优化过程中，可以通过将WHERE子句中的条件表达式转换为数据存储引擎中的表达式来实现，从而使得数据引擎能够利用索引等机制进行更高效的数据筛选和过滤操作，避免对无关记录的全表扫描和计算，从而显著提升查询效率和响应速度

谓词下推是指在查询生成计划之后，尽可能将查询过程中的限制条件下推到最低层的存储引擎中，以减少所访问的数据量。具体来说，在查询执行过程中，如果查询引擎发现了查询计划树上某个节点的输入（即子节点）需要读取大量不必要的数据，则可以通过谓词下推先筛选出部分无效数据，从而减轻后续处理大量数据的压力，提高整体查询性能。

举个例子，一个包含了WHERE语句的SQL查询，在涉及多张表的情况下，SQL 查询解析器会把 WHERE 子句中的过滤条件移动到最具有可行性的 SQL 语句位置，这样就可以避免需要读取和处理那些不需要的记录集。这个被称为“谓词下推”的技术通常用于在查询计划阶段去掉不必要的JOPIN和WHERE语句。

### 运行时过滤器

相对于谓词下推而言，运行时过滤器是一种更加广义的概念，它可以在查询执行过程中的任何阶段进行比对，并根据运行时数据进行剪枝操作，从而减少不必要的计算和资源消耗。具体来说，在查询执行过程中，如果Doris引擎发现了某个分区或者块不存在符合要求的记录，则可以启用运行时过滤器丢弃掉这些无效数据，从而获得更快的检索速度。

因此，虽然谓词下推和运行时过滤器的优化方式略有不同，但它们都旨在尽量降低查询过程中所访问的数据量，提高查询性能。

### BE

Fragment Execute线程池，默认最小线程64个，最大512个线程，住宿是默认 48 线程（Scanner 线程池）

### Instance

代表了并发，可以通过parallel_fragment_exec_instance_num调整；一个instance可以扫描1个副本，也可以扫描多个副本

### Scanner

一个instance最多拆成 64个scanner

**BE 扫描区间拆分：**Scanner 线程池默认大小为 48，1 个 OlapScanNode Instance 会提交多少个 Scanner 由以下因素决定：一个副本至少一个 Scanner，具体是多少看前缀索引字段谓词能不能把扫描天然拆解成多个互不冲突的区间，如果不能大概率最终结果是 1 个副本 1 个 Scanner

### 大查询

大查询导致集群挂掉的原因是：scanner线程被占用完，其他查询无法使用scanner扫描数据

### Spark on doris

对于spark on doris类型的外部查询（非查询引擎直接执行），可能由于没有query_timeout的限制，导致scanner线程被长期占用，一个查询扫描几个小时的数据是可能发生的，这种query一定需要治理，否则会对集群产生很大的伤害
