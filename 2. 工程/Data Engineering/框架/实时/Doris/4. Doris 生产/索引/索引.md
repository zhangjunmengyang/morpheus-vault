# 索引

Apache Doris 存储引擎采用类似 LSM 树的结构提供快速的数据写入支持。进行数据导入时，数据会先写入 Tablet 对应的 MemTable 中，

MemTable 采用 SkipList 的数据结构，将数据暂时保存在内存中，SkipList 会按照 Key 对数据行进行排序，因此，刷写到磁盘上的 Segment 文件也是按 Key 排序的。Apache Doris 底层采用列存的方式来存储数据，每一列数据会被分为多个 Data Page。

当 MemTable 写满之后，会将 MemTable 里的数据 刷写（Flush）到磁盘，生成一个个 不超过 256MB 的不可变的 Segment 文件。

## 一、基本概念

从加速的查询和原理来看，Apache Doris 的索引分为点查索引和跳数索引两大类。

点查索引：常用于加速点查，原理是通过索引定位到满足 WHERE 条件的有哪些行，直接读取那些行。点查索引在满足条件的行比较少时效果很好。Apache Doris 的点查索引包括前缀索引和倒排索引。

- 前缀索引：Apache Doris 按照排序键以有序的方式存储数据，并每隔 1024 行数据创建一个稀疏前缀索引。索引中的 Key 是当前 1024 行中第一行中排序列的值。如果查询涉及已排序列，系统将找到相关 1024 行组的第一行并从那里开始扫描。
- 倒排索引：对创建了倒排索引的列，建立每个值到对应行号集合的倒排表。对于等值查询，先从倒排表中查到行号集合，然后直接读取对应行的数据，而不用逐行扫描匹配数据，从而减少 I/O 加速查询。倒排索引还能加速范围过滤、文本关键词匹配，算法更加复杂但是基本原理类似。（备注：之前的 BITMAP 索引已经被更强的倒排索引取代）
跳数索引：常用于加速分析，原理是通过索引确定不满足 WHERE 条件的数据块，跳过这些不满足条件的数据块，只读取可能满足条件的数据块并再进行一次逐行过滤，最终得到满足条件的行。跳数索引在满足条件的行比较多时效果较好。Apache Doris 的跳数索引包括 ZoneMap 索引、BloomFilter 索引、NGram BloomFilter 索引。

- ZoneMap 索引：自动维护每一列的统计信息，为每一个数据文件（Segment）和数据块（Page）记录最大值、最小值、是否有 NULL。对于等值查询、范围查询、IS NULL，可以通过最大值、最小值、是否有NULL 来判断数据文件和数据块是否可以包含满足条件的数据，如果没有则跳过不读对应的文件或数据块减少 I/O 加速查询。
- BloomFilter 索引：将索引对应列的可能取值存入 BloomFilter 数据结构中，它可以快速判断一个值是否在 BloomFilter里面，并且 BloomFilter 存储空间占用很低。对于等值查询，如果判断这个值不在 BloomFilter 里面，就可以跳过对应的数据文件或者数据块减少 I/O 加速查询。
上述索引中，前缀索引、Ordinal 索引 和 ZoneMap 索引是 Apache Doris 自动维护的内建智能索引，无需用户管理，而倒排索引、BloomFilter 索引则需要用户自己根据场景选择，手动创建、删除。

## 二、前缀索引

Apache Doris 的数据存储在类似 SSTable（Sorted String Table）的数据结构中。该结构是一种有序的数据结构，可以按照指定的一个或多个列进行排序存储。在这种数据结构上，以排序列的全部或者前面几个作为条件进行查找，会非常的高效。

刷写过程中，每1024行数据生成一个前缀索引项，一个 Segment 文件中的前缀索引数据保存在一个独立的 Short Key Page 中，其中包含每一条前缀索引项的编码数据、每一条前缀索引项的 offset、Short Key Page 的 footer 以及 Short Key Page 的 Checksum 信息。Short Key Page 的 footer 中记录了 Page 的类型、前缀索引编码数据的大小、前缀索引 offset 数据的大小、前缀索引项的数目等信息。

Short Key Page 在 Segment 中的 offset 和大小会被保存在Segment文件的footer中，以便于数据读取时能够正确地从Segment文件中加载出前缀索引数据。前缀索引的存储结构如图1所示。

数据查询时，会打开Segment文件，从 footer 中获取 Short Key Page 的 offset 以及大小，然后从Segment文件中读取Short Key Page中的索引数据，并解析出每一条前缀索引项。

前缀索引依赖的是底层的数据存储的 key 的有序性（Aggregate Key、Unique Key 和 Duplicate Key），这些 Key，称为排序键（Sort Key）。借助排序键，在查询时，通过给排序列指定条件，Apache Doris 不需要扫描全表，加速查询。

关键点：

- 前缀索引是稀疏索引，不能精确定位数据所在行，只能粗略定位数据可能存在范围，并使用二分查找精确定位数据位置。
- 数据行的前36个字节作为前缀索引，遇到varchar时会直接截断（取前20字节），即使没有达到36个字节。
- 命中前缀索引条件：= < > <= >= in between并使用and连接，between以及< >划定范围时，值范围必须<=128。
前缀索引是一种稀疏索引。表中按照相应的行数的数据构成一个逻辑数据块 (Data Block)。每个逻辑数据块在前缀索引表中存储一个索引项，索引项的长度不超过 36 字节，其内容为数据块中第一行数据的排序列组成的前缀，在查找前缀索引表时可以帮助确定该行数据所在逻辑数据块的起始行号。由于前缀索引比较小，所以，可以全量在内存缓存，快速定位数据块，大大提升了查询效率。

数据块一行数据的前 36 个字节作为这行数据的前缀索引。当遇到 VARCHAR 类型时，前缀索引会直接截断。如果第一列即为 VARCHAR，那么即使没有达到 36 字节，也会直接截断，后面的列不再加入前缀索引。

生产环境推荐规约：

- 建表时，正确的选择列顺序，能够极大地提高查询效率。
- 因为建表时已经指定了列顺序，所以一个表只有**一种**前缀索引。这对于使用其他不能命中前缀索引的列作为条件进行的查询来说，效率上可能无法满足需求，这种情况，我们可以通过创建物化视图（rollup）来人为的调整列顺序。
- 前缀索引的第一个字段一定是最常查询的字段，并且需要是高基数字段：
- 分桶字段注意事项：这个一般是数据分布比较均衡的，也是经常使用的字段
- 前缀索引（36 位）：第一个字段查询性能最好，前缀索引碰见 varchar 类型的字段，**会自动截断前20个字符**
- Int（4）+ Int（4） + varchar(50)，前缀索引长度只有 28
- Int（4） + varchar(50) + Int（4），前缀索引长度只有 24
- varchar(10) + varchar(50) ，前缀索引长度只有 30
- 最常用的查询字段如果能放到前缀索引里尽可能放到前前缀索引里，如果不能，可以放到分桶字段里
前缀索引中的字段长度尽可能明确，因为 Doris 只有前 36 个字节能走前缀索引。

如果某个范围数据在分区分桶和前缀索引中都不好设计，可以考虑引入**倒排索引**加速。

当where条件中包含Key的**前缀列**时，能够触发前缀索引，加速过滤

建表时字段顺序(k1 key,k2 key,k3 key,v1 value,v2 value)

- where k1 and k2 能够命中前缀索引
- where k1 and k3 能够命中前缀索引(但只有k1能够命中)
- where k3 不能够命中前缀索引
前缀key列的一些注意事项

1. 前缀索引遇到字符串会截断，所以如果有字符串，尽量放在前缀索引的后面几列
1. 在不影响前缀索引命中的前提下，尽量把Int列放在前缀的第一位，Int的过滤要比字符串等要快
1. 前缀索引一般不超过3列。
## 三、oridinal 索引

### 3.1 索引生成

Apache Doris 底层采用列存的方式来存储数据，每一列数据会被分为多个Data Page。

数据刷写时，会为每一个 Data Page 生成一条 Ordinal 索引项，其中保存 Data Page 在Segment文件中的 offset 、Data Page的大小 以及 Data Page的 起始行号，所有Data Page的Ordinal索引项会保存在一个Ordinal Index Page 中， Ordinal Index Page在Segment文件中的offset以及Ordinal Index Page的大小会被保存在Segment文件的footer中，以便于数据读取时能够通过两级索引找到Data Page（首先，通过Segment文件的footer找到Ordinal Index Page，然后，通过Ordinal Index Page中的索引项找到Data Page）。

Ordinal Index Page包含以下信息：所有Ordinal索引项数据、Ordinal Index Page的footer以及Short Key Page的Checksum信息。Ordinal Index Page的footer中包含当前Page的类型、Ordinal索引项数据的大小、Ordinal索引项数目等信息。

如果列中只有一个Data Page时，即该列只有一条Ordinal索引项，则Segment文件中不需要保存该列的Ordinal索引数据，只需要将这唯一的Data Page在Segment文件中的offset以及该Data Page的大小保存在Segment文件的footer中。数据读取时可以通过Segment文件的footer直接找到这唯一的Data Page。Ordinal索引的存储结构如图3所示。

Ordinal索引的作用是为了方便其他类型的索引能够使用统一的方式查找Data Page，进而可以对其他类型的索引屏蔽Data Page在Segment文件中的offset。

3.2  查询过滤

数据查询时，会加载每一个列的Ordinal索引数据。通过Segment footer中记录的Ordinal索引的Meta信息判断当前列是否存在Ordinal Index Page，即判断当前列是否有多个Data Page。

如果当前列存在Ordinal Index Page，则从Segment footer中获取Ordinal Index Page在Segment中的offset和Ordinal Index Page的大小，然后从Segment文件中读取Ordinal Index Page数据，并解析出每一条Ordinal索引项，即可通过Ordinal索引项获取当前列中每一个Data Page的起始行号、Data Page在Segment中的offset以及Data Page的大小。

如果当前列不存在Ordinal Index Page，则可以直接从Segment footer中获取当前列中唯一的Data Page在Segment中的offset以及Data Page的大小。

3  Ordinal 索引

### 3.1 索引生成

Apache Doris 底层采用列存的方式来存储数据，每一列数据会被分为多个Data Page。

数据刷写时，会为每一个Data Page生成一条Ordinal索引项，其中保存Data Page在Segment文件中的offset、Data Page的大小以及Data Page的起始行号，所有Data Page的Ordinal索引项会保存在一个Ordinal Index Page中， Ordinal Index Page在Segment文件中的offset以及Ordinal Index Page的大小会被保存在Segment文件的footer中，以便于数据读取时能够通过两级索引找到Data Page（首先，通过Segment文件的footer找到Ordinal Index Page，然后，通过Ordinal Index Page中的索引项找到Data Page）。

Ordinal Index Page包含以下信息：所有Ordinal索引项数据、Ordinal Index Page的footer以及Short Key Page的Checksum信息。Ordinal Index Page的footer中包含当前Page的类型、Ordinal索引项数据的大小、Ordinal索引项数目等信息。

如果列中只有一个Data Page时，即该列只有一条Ordinal索引项，则Segment文件中不需要保存该列的Ordinal索引数据，只需要将这唯一的Data Page在Segment文件中的offset以及该Data Page的大小保存在Segment文件的footer中。数据读取时可以通过Segment文件的footer直接找到这唯一的Data Page。Ordinal索引的存储结构如图3所示。

Ordinal索引的作用是为了方便其他类型的索引能够使用统一的方式查找Data Page，进而可以对其他类型的索引屏蔽Data Page在Segment文件中的offset。

3.2  查询过滤

数据查询时，会加载每一个列的Ordinal索引数据。通过Segment footer中记录的Ordinal索引的Meta信息判断当前列是否存在Ordinal Index Page，即判断当前列是否有多个Data Page。

如果当前列存在Ordinal Index Page，则从Segment footer中获取Ordinal Index Page在Segment中的offset和Ordinal Index Page的大小，然后从Segment文件中读取Ordinal Index Page数据，并解析出每一条Ordinal索引项，即可通过Ordinal索引项获取当前列中每一个Data Page的起始行号、Data Page在Segment中的offset以及Data Page的大小。

如果当前列不存在Ordinal Index Page，则可以直接从Segment footer中获取当前列中唯一的Data Page在Segment中的offset以及Data Page的大小。

4 Zone Map 索引

Apache Doris 会为Segment文件中的一列数据添加Zone Map索引，同时会为列中的每一个Data Page添加Zone Map索引。Zone Map索引项中记录了每一列或列中每一个Data Page的最大值(max value)、最小值(min value)、是否有null值(has null)以及是否有非null值(has not null)的信息。初始化时，max value会被设置为当前列类型的最小值，min value会被设置为当前列类型的最大值，has null和has not null会被设置为false。

4.1 索引生成

数据刷写时，会给每一个Data Page创建一条Zone Map索引项。向Data Page中每添加一条数据，都会更新Data Page的Zone Map索引项。

如果添加的数据是null，则将Zone Map索引项的has null标志设置为true，否则，将Zone Map索引项的has not null标志设置为true。

如果添加的数据小于Zone Map索引项的min value，则使用当前数据更新min value；如果添加的数据大于Zone Map索引项的max value，则使用当前数据更新max value。

当一个Data Page写满之后，会更新一次列的Zone Map索引项，如果Data Page索引项的min value小于列索引项的min value，则使用Data Page索引项的min value更新列索引项的min value；如果Data Page索引项的max value大于列索引项的max value，则使用Data Page索引项的max value更新列索引项的max value；如果Data Page索引项的has null标志为true，则更新列索引项的has null标志为true；如果Data Page索引项的has not null标志为true，则更新列索引项的has  not null标志为true。更新Zone Map索引的过程如图4所示。

列中每一个Data Page的Zone Map索引项会被序列化之后保存在Zone Map Index Page中。

Zone Map Index Page中包含以下信息：Zone Map索引项数据、Zone Map Index Page的footer以及Zone Map Index Page的Checksum信息。

Zone Map Index Page的footer中包含当前Page的类型、当前Page中Zone Map索引项数据的大小、当前Page中Zone Map索引项数目以及当前Page中第一条索引项在整个列的Zone Map索引项中的序号等信息。

一个Zone Map Index Page写满之后，会创建新的Zone Map Index Page用于记录该列后续的Zone Map索引项。

如果某一列有多个Zone Map Index Page，则该列的Zone Map索引会采用两级索引机制。第二级索引为多个的Zone Map Index Page，其中保存Data Page的Zone Map索引数据，每一个Zone Map Index Page会生成一条Ordinal索引项，所有Zone Map Index Page的Ordinal索引项会被保存在一个Ordinal Index Page（注意，此处的Ordinal 索引与第3部分的Ordinal 索引不同，此处的Ordinal 索引指向Zone Map Index Page，而第3部分的Ordinal 索引指向Data Page）中作为一级索引。

每一个的Ordinal索引项由key和value两部分组成，key记录了当前Zone Map Index Page中第一条索引项在整个列的Zone Map索引项中的序号，value记录了当前Zone Map Index Page在Segment文件中的offset和大小。

Ordinal Index Page中包含以下信息：所有Zone Map Index Page的Ordinal 索引数据、Ordinal Index Page的footer以及Ordinal Index Page的Checksum信息。Ordinal Index Page的footer中包含当前Page的类型、当前Page中索引数据的大小、当前Page中索引项数目等。

一级索引Ordinal Index Page在Segment文件中的offset和大小会被记录在Segment文件的footer中。如果某一列只有一个Zone Map Index Page，则不需要两级索引，这个唯一的Zone Map Index Page在Block中的offset和大小会被记录在Segment文件的footer中。Zone Map索引的存储结构如图5所示。

4.2  查询过滤

数据查询时，会加载每一个列的Zone Map索引数据，并解析出每一个Data Page的Zone Map索引数据。

通过Segment footer中记录的Zone Map索引的Meta信息判断当前列的Zone Map是否含有两级索引。

如果含有两级索引，则Segment footer中记录了一级索引Ordinal Index Page在Segment文件中的offset和大小，加载一级索引Ordinal Index Page，并解析出每一个的Ordinal索引项的key和value，key记录了每一个Zone Map Index Page中第一条索引项在整个列所有的Zone Map索引项中的序号，value记录了每一个Zone Map Index Page在Segment文件中的offset和大小。

否则，当前列的Zone Map索引只含有一个Zone Map Index Page，Segment footer中记录了该Zone Map Index Page在Segment文件中的offset和大小。可以通过Zone Map Index Page解析出每一个Data Page的Zone Map索引数据，其中包括最大值(max value)、最小值(min value)、是否有null值(has null)以及是否有非null值(has not null)的信息。

使用Zone Map对Data Page进行过滤的方法如下：

过滤条件的运算符不是IS。如果Zone Map索引的has null为true（Data Page中含有NULL值），则Data Page不能被过滤掉。

过滤条件为 field = value。如果 value在Zone Map索引的最大值与最小值之间，则Data Page不能被过滤掉。

过滤条件为 field != value。如果value小于Zone Map索引的最小值或value大于Zone Map索引的最大值，则Data Page不能被过滤掉。

过滤条件为 field < value。如果value大于Zone Map索引的最小值，则Data Page不能被过滤掉。

过滤条件为 field <= value。如果value大于或等于Zone Map索引的最小值，则Data Page不能被过滤掉。

过滤条件为 field > value。如果value小于Zone Map索引的最大值，则Data Page不能被过滤掉。

过滤条件为 field >= value。如果value小于或等于Zone Map索引的最大值，则Data Page不能被过滤掉。

过滤条件为 field IN {value1, value2, ...}。如果value1、value2、...中至少存在一个值在Zone Map索引的最大值与最小值之间，则Data Page不能被过滤掉。

过滤条件为 field IS NULL。如果Zone Map索引的has null为true（Data Page中含有NULL值），则Data Page不能被过滤掉。

过滤条件为 field IS NOT NULL。如果Zone Map索引的has not null为true（Data Page中含有非NULL值），则Data Page不能被过滤掉。

对于未被Zone Map索引过滤的Data Page，可以使用Ordinal索引快速定位这些Data Page的起始行的行号，并获取这些Data Page的行范围。通过Data Page对应的Ordinal索引项快速获取当前Data Page的起始行的行号start，通过下一条Ordinal索引项快速获取后一个Data Page的起始行的行号end，左闭右开区间[start, end)即为当前Data Page的row范围。

5 Bitmap 索引

为了加速数据查询，Apache Doris支持用户为某些字段添加Bitmap索引。Bitmap索引由两部分组成：

有序字典：有序保存一列中所有的不同取值。

字典值的Roaring位图：保存有序字典中每一个取值的Roaring位图，表示字典值在列中的行号。

例如：如图6所示，一列数据为[x, x, y, y, y, z, y, x, z, x]，一共包含10行，则该列数据的Bitmap索引的有序字典为{x, y, z}, x、y、z对应的位图分别为：

x的位图: [0, 1, 7, 9]

y的位图: [2, 3, 4, 6]

z的位图: [5, 8]

5.1 索引生成

数据刷写时，会给用户指定的列创建Bitmap索引。向列中每添加一个值，都会更新当前列的Bitmap索引。从Bitmap索引的有序字典中查找添加的值是否已经存在，如果本次添加的值在Bitmap索引的有序字典中已经存在，则直接更新该字典值对应的Roaring位图，如果本次添加的值在Bitmap索引的有序字典中不存在，则将该值添加到有序字典，并为该字典值创建Roaring位图。当然，NULL值也会有单独的Roaring位图。

Bitmap索引的字典数据和Roaring位图数据分开存储。

列中Bitmap索引的字典值会按顺序保存在Dict Page中。Dict Page中包含以下信息：Bitmap索引的字典数据、Dict Page的footer以及Dict Page的Checksum信息。Dict Page的footer中包含当前Page的类型、当前Page中Bitmap索引的字典数据的大小、当前Page中Bitmap索引的字典值数目以及当前Page中第一个字典值在整个列的Bitmap索引字典值中的序号等信息。Bitmap索引的字典数据会按照LZ4F格式进行压缩。

一个Dict Page写满之后，会创建新的Dict Page用于记录该列后续的字典数据。

如果某一列有多个Dict Page，则会采用两级索引机制。第二级索引为多个的Dict Page，其中保存Bitmap索引的字典数据，每一个Dict Page生成一条Value索引项，所有Dict Page的Value索引项会被保存在一个Value Index Page中作为一级索引。每一个的Value索引项记录了当前Dict Page中第一个字典值的编码以及当前Dict Page在Segment文件中的offset和大小。

Value Index Page中包含以下信息：所有Dict Page的Value索引数据、Value Index Page的footer以及Value Index Page的Checksum信息。Value Index Page的footer中包含当前Page的类型、当前Page中索引数据的大小、当前Page中索引项数目等。

一级索引Value Index Page在Segment文件中的offset和大小会被记录在Segment文件的footer中。如果某一列只有一个Dict Page，则不需要两级索引，这个唯一的Dict Page在Segment文件中的offset和大小会被记录在Segment文件的footer中。Bitmap索引的字典数据的存储结构如图7所示。

列中Bitmap索引的Roaring位图数据会保存在Bitmap Page中。

Bitmap Page中包含以下信息：Bitmap索引的Roaring位图数据、Bitmap Page的footer以及Bitmap Page的Checksum信息。

Bitmap Page的footer中包含当前Page的类型、当前Page中Bitmap索引的Roaring位图数据的大小、当前Page中Bitmap索引的Roaring位图数目以及当前Page中第一个Roaring位图在整个列的Bitmap索引的Roaring位图中的序号等信息。Bitmap索引的Roaring位图数据不进行压缩。

一个Bitmap Page写满之后，会创建新的Bitmap Page用于记录该列后续的Roaring位图数据。

如果某一列有多个Bitmap Page，则会采用两级索引机制。第二级索引为多个的Bitmap Page，其中保存Bitmap索引的位图数据，每一个Bitmap Page生成一条Ordinal索引项，所有Bitmap Page的Ordinal索引项会被保存在一个Ordinal Index Page（注意，此处的Ordinal 索引与第3部分的Ordinal 索引不同，此处的Ordinal 索引指向Bitmap Page，而第3部分的Ordinal 索引指向Data Page）中作为一级索引。

每一个的Ordinal索引项由key和value两部分组成，key记录了当前Bitmap Page中第一个Roaring位图在整个列的BitMap索引Roaring位图中的序号，value记录了当前Bitmap Page在Segment文件中的offset和大小。

Ordinal Index Page中包含以下信息：所有Bitmap Page的Ordinal 索引数据、Ordinal Index Page的footer以及Ordinal Index Page的Checksum信息。Ordinal Index Page的footer中包含当前Page的类型、当前Page中索引数据的大小、当前Page中索引项数目等。

一级索引Ordinal Index Page在Segment文件中的offset和大小会被记录在Segment文件的footer中。如果某一列只有一个Bitmap Page，则不需要两级索引，这个唯一的Bitmap Page在Segment文件中的offset和大小会被记录在Segment文件的footer中。Bitmap索引的Roaring位图数据的存储结构如图8所示。

5.2  查询过滤

数据查询时，会加载列的Bitmap索引数据，并解析出有序字典和Roaring位图数据。

首先，通过Segment footer中记录的Bitmap索引的字典Meta信息判断当前列的Bitmap索引的字典是否含有两级索引，如果含有两级索引，则Segment footer中记录了一级索引Value Index Page在Block中的offset和大小，首先加载一级索引Value Index Page，并解析出每一个的Value索引项，获得每一个Dict Page中第一个字典值和每一个Dict Page在Segment文件中的offset和大小；否则，当前列的Bitmap索引只含有一个Dict Page，Segment footer中记录了该Dict Page在Segment文件中的offset和大小。可以通过Dict Page解析出每一个字典值。

然后，通过Segment footer中记录的Bitmap索引的Roaring位图Meta信息判断当前列的Bitmap索引的Roaring位图是否含有两级索引，如果含有两级索引，则Segment footer中记录了一级索引Ordinal Index Page在Segment文件中的offset和大小，首先加载一级索引Ordinal Index Page，并解析出每一个的Ordinal索引项，获得每一个Bitmap Page中第一个Roaring位图在整个列的Bitmap索引Roaring位图中的序号以及每一个Bitmap Page在Segment文件中的offset和大小；否则，当前列的Bitmap索引只含有一个Bitmap Page，Segment footer中记录了该Bitmap Page在Segment文件中的offset和大小。可以通过Bitmap Page中解析出每一个字典值对应的Roaring位图。

真正使用Bitmap索引进行数据过滤时才会加载Dict Page和Bitmap Page。

使用某一个查询过滤条件进行行过滤的方法如下：

过滤条件为 field = value。从 Dict Page 中寻找第一个等于或大于 value 的字典值，并且获取该字典值在有序字典中的序号ordinal。如果寻找到的字典值恰好等于value，则从 Bitmap Page 中读取第ordinal个位图，则该位图表示通过该查询条件过滤之后留下的行范围。

过滤条件为 field != value。从Dict Page中寻找第一个等于或大于value的字典值，并且获取该字典值在有序字典中的序号ordinal。如果寻找到的字典值恰好等于value，则从Bitmap Page中读取第ordinal个位图，则该位图表示需要被过滤掉的行范围。

过滤条件为 field < value。从Dict Page中寻找第一个等于或大于value的字典值，并且获取该字典值在有序字典中的序号ordinal。从Bitmap Page中读取前面ordinal个位图，这些位图的并集表示通过该查询条件过滤之后留下的行范围。

过滤条件为 field <= value。从Dict Page中寻找第一个等于或大于value的字典值，并且获取该字典值在有序字典中的序号ordinal。如果寻找到的字典值恰好等于value，则从Bitmap Page中读取前面ordinal + 1个位图；如果寻找到的字典值大于value，则从Bitmap Page中读取前面ordinal个位图，这些位图的并集表示通过该查询条件过滤之后留下的行范围。

过滤条件为 field > value。从Dict Page中寻找第一个等于或大于value的字典值，并且获取该字典值在有序字典中的序号ordinal。如果寻找到的字典值恰好等于value，则从Bitmap Page中读取第ordinal个位图之后的所有位图；如果寻找到的字典值大于value，则从Bitmap Page中读取第ordinal以及之后的所有位图，这些位图的并集表示通过该查询条件过滤之后留下的行范围。

过滤条件为 field >= value。从Dict Page中寻找第一个等于或大于value的字典值，并且获取该字典值在有序字典中的序号ordinal。从Bitmap Page中读取ordinal之后的所有位图，这些位图的并集表示通过该查询条件过滤之后留下的行范围。

5.3  适用场景

Apache Doris支持在建表时对指定的列创建Bitmap索引，也可以对已经创建的表执行Alter Table命令添加Bitmap索引

Apache Doris支持在建表时对指定的列创建Bitmap索引，也可以对已经创建的表执行Alter Table命令添加Bitmap索引。

目前只支持对TINYINT、SMALLINT、INT、 UNSIGNEDINT、BIGINT、LARGEINT、CHAR、 VARCHAR、DATE、DATETIME、BOOL和DECIMAL类型的字段创建Bitmap索引，其他类型的字段均不支持Bitmap索引。Bitmap索引比较适合在基数较低的列上进行等值查询或范围查询的场景。

6   Bloom Filter 索引 

Apache Doris支持用户对取值区分度比较大的字段添加Bloom Filter索引，Bloom Filter索引按照Data Page的粒度生成。数据写入时，会记录每一个写入Data Page的值，当一个Data Page写满之后，会根据该Data Page的所有不同取值为该Data Page生成Bloom Filter索引。数据查询时，查询条件在设置有Bloom Filter索引的字段进行过滤，当某个Data Page的Bloom Filter没有命中时，表示该Data Page中没有需要的数据，这样可以对Data Page进行快速过滤，减少不必要的数据读取。

6.1 索引生成

数据刷写时，会给每一个Data Page创建一条Bloom Filter索引项。Apache Doris采用了基于Block的Bloom Filter算法。每一个Data Page对应的Bloom Filter索引数据会被划分为多个Block，每个Block的数据长度为BYTES_PER_BLOCK（默认为32字节，共256bit），Block中的每一个Bit位会被初始化为0。向Data Page中写入数据时，每一个不同的取值value都会将一个Block中的BITS_SET_PER_BLOCK（默认值为8）个Bit置位为1。Bloom Filter索引的结构如图9所示。

单个Data Page的Bloom Filter索引数据长度BLOOM_FILTER_BIT通过如下公式计算：

1

BLOOM_FILTER_BIT = -N * ln(FPP) / (ln(2) ^ 2) 

其中，N表示当前Data Page中的不同取值的个数；FPP（False Positive Probablity） 表示期望的误判率，默认取值为0.05。（注：计算出的Bloom Filter数据长度（单位为bit）一定是2的整数次幂。）

Bloom Filter中，每一个Block的长度为BYTES_PER_BLOCK（32字节），因此，Bloom Filter中的Block数量通过如下公式计算：

1

BLOCK_NUM = (BLOOM_FILTER_BIT / 8)  / BYTES_PER_BLOCK; 

为Data Page生成Bloom Filter索引项的方法如下：

针对Data Page中的每一个不同的取值value，计算出一个64位的HASH_CODE。Apache Doris中，Bloom Filter的Hash策略为HASH_MURMUR3。

取HASH_CODE的高32位计算出当前value在Bloom Filter中对应的Block，方法如下：

1

BLOCK_INDEX = (HASH_CODE >> 32) & (BLOCK_NUM - 1) 

其中，BLOCK_INDEX表示Block的序号，BLOCK_NUM为2的整数次幂，则BLOCK_INDEX一定小于BLOCK_NUM。

取HASH_CODE的低32位计算出当前value会将Block中的哪些Bit置位为1，方法如下：

其中，masks[i]包含32个Bit，其中只有1个Bit被置位为1，其他31个Bit均为0。

将masks[i]与Block中第i个32Bit按位取或，更新Data Page的Bloom Filter索引数据。（一个Block中包含256个Bit，即 BITS_SET_PER_BLOCK 个32 Bit）   

```
uint32_t* BLOCK_OFFSET =  BLOOM_FILTER_OFFSET + BYTES_PER_BLOCK * BLOCK_INDEX

for (int i = 0; i < BITS_SET_PER_BLOCK; ++i) {
*(BLOCK_OFFSET + i) |= masks[i];
}
```

其中，BLOOM_FILTER_OFFSET表示当前Data Page的Bloom Filter的偏置，BLOCK_OFFSET表示当前block的偏置。

Bloom Filter索引项中单独设置了Data Page中是否包含了NULL值的标志。

列中每一个Data Page的Bloom Filter索引项会被保存在Bloom Filter Index Page中。Bloom Filter Index Page中包含以下信息：Bloom Filter索引项数据、Bloom Filter Index Page的footer以及Bloom Filter Index Page的Checksum信息。Bloom Filter Index Page的footer中包含当前Page的类型、当前Page中Bloom Filter索引项数据的大小、当前Page中Bloom Filter索引项数目以及当前Page中第一条索引项在整个列的Bloom Filter索引项中的序号等信息。

一个Bloom Filter Index Page写满之后，会创建新的Bloom Filter Index Page用于记录该列后续的Bloom Filter索引项。如果某一列有多个Bloom Filter Index Page，则该列的Bloom Filter索引会采用两级索引机制。第二级索引为多个的Bloom Filter Index Page，其中保存Data Page的Bloom Filter索引数据，每一个Bloom Filter Index Page生成一条Ordinal索引项，所有Bloom Filter Index Page的Ordinal索引项会被保存在一个Ordinal Index Page（注意，此处的Ordinal 索引与第3部分的Ordinal 索引不同，此处的Ordinal 索引指向Bloom Filter Index Page，而第3部分的Ordinal 索引指向Data Page）中作为一级索引。

每一个的Ordinal索引项由key和value两部分组成，key记录了当前Bloom Filter Index Page中第一条索引项在整个列的Bloom Filter索引项中的序号，value记录了当前Bloom Filter Index Page在Segment文件中的offset和大小。Ordinal Index Page中包含以下信息：所有Bloom Filter Index Page的Ordinal 索引数据、Ordinal Index Page的footer以及Ordinal Index Page的Checksum信息。Ordinal Index Page的footer中包含当前Page的类型、当前Page中索引数据的大小、当前Page中索引项数目等。一级索引Ordinal Index Page在Segment文件中的offset和大小会被记录在Segment文件的footer中。如果某一列只有一个Bloom Filter Index Page，则不需要两级索引，这个唯一的Bloom Filter Index Page在Segment文件中的offset和大小会被记录在Segment文件的footer中。Bloom Filter索引的存储结构如图10所示

6.2 查询过滤

数据查询时，会加载列的Bloom Filter索引数据，并解析出每一个Data Page的Bloom Filter索引项。首先，通过Segment footer中记录的Bloom Filter索引的Meta信息判断当前列的Bloom Filter是否含有两级索引，如果含有两级索引，则Segment footer中记录了一级索引Ordinal Index Page在Segment文件中的offset和大小，先加载一级索引Ordinal Index Page，并解析出每一个的Ordinal索引项的key和value，key记录了每一个Bloom Filter Index Page中第一条索引项在整个列所有的Bloom Filter索引项中的序号，value记录了每一个Bloom Filter Index Page在Segment文件中的offset和大小；否则，当前列的Bloom Filter索引只含有一个Bloom Filter Index Page，Segment footer中记录了该Bloom Filter Index Page在Segment文件中的offset和大小。可以通过Bloom Filter Index Page解析出每一个Data Page的Bloom Filter索引数据。

判断某个值value是否命中Bloom Filter的方法如下：

首先，基于HASH_MURMUR3方法对查询过滤条件的值value计算出64位的HASH_CODE；

然后，采用与生成Bloom Filter索引数据相同的方法计算出该value值在Bloom Filter中对应的Block，以及在Block中对应的BITS_SET_PER_BLOCK个Bit位。

判断Bloom Filter索引数据中对应Block的这BITS_SET_PER_BLOCK个Bit的值是否均为1。如果对应Block中的这BITS_SET_PER_BLOCK个Bit值均为1，则表示Bloom Filter命中，该value值在Bloom Filter对应的Data Page中可能存在；否则，表示Bloom Filter未命中，该value值在Bloom Filter对应的Data Page中一定不存在。

数据查询时，查询过滤条件（"="、"IS"或"IN"语句）在设置有Bloom Filter索引的列依次对每一个Data Page进行过滤。进行NULL值查询时，可以直接使用Bloom Filter索引项中的NULL值标志进行Data Page过滤。进行非NULL值查询时，使用查询过滤条件对Data Page进行过滤的方法如下：

过滤条件为  field = value 。如果value未命中某一个Data Page对应的Bloom Filter，则该Data Page可以被过滤掉。

过滤条件为  field IN {value1, value2, ...} 。如果 value1、value2、...中所有值都未命中某一个Data Page对应的Bloom Filter，则该Data Page可以被过滤掉。

过滤条件为  field IS NULL 。如果NULL值未命中某一个Data Page对应的Bloom Filter，则该Data Page可以被过滤掉。

6.3 适用场景

Apache Doris支持在建表时对指定的列创建Bloom Filter索引，也可以对已经创建的表执行Alter Table命令添加Bloom Filter索引。

1

ALTER TABLE table_name SET ("bloom_filter_columns"="c1, c2, c3"); 

目前只支持对SMALLINT、INT、UNSIGNEDINT、 BIGINT、LARGEINT、CHAR、 VARCHAR、DATE、DATETIME和DECIMAL类型的字段创建Bloom Filter索引，其他类型的字段均不支持Bloom Filter索引。对于创建了Bloom Filter索引的字段，查询条件是"="、"is"或"in"语句时，才会使用Bloom Filter索引进行Data Page的过滤。Bloom Filter索引比较适合在基数较高的列上进行等值查询的场景。

结束语

为了加快数据查询效率，Apache Doris 的存储引擎提供了前缀索引、Ordinal 索引、Zone Map索引、Bitmap 索引和 Bloom Filter 索引，可以在数据读取之前快速地进行数据过滤。前缀索引、Ordinal 索引和 Zone Map 索引不需要用户干预，会随着数据写入自动生成；数据写入时默认不会生成 Bitmap 索引和 Bloom Filter 索引，用户可以有选择地为指定的列添加这两种索引。本文主要从数据写入过程中索引的生成、索引的物理存储结构以及数据查询过程中如何使用索引进行数据过滤等方面对这几种索引的的底层机制分别进行了详细地剖析。
