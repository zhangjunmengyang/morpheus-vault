---
title: "Exactly Once 语义"
type: concept
domain: engineering/flink/checkpoint
created: "2026-02-13"
updated: "2026-02-13"
tags:
  - engineering/flink/checkpoint
  - type/concept
---
# Exactly Once 语义

## 7、Exactly-Once

### 7.1、Flink Exactly-Once

需要保证source、中间计算和sink层同时满足端到端严格一次处理。

- source：保存消费数据的偏移量offset，一旦故障，可以重新消费数据。
- 计算：利用cp将状态定期持久化，一旦故障，可以从cp恢复。
- sink：两阶段提交，外部系统支持提交和回滚事务操作。
- 两阶段提交：
- cp启动，进入预提交阶段，sink先把数据写入到外部（预写日志），此时属于预提交的事务，还不能被消费。
- 当cp完成后，JM向所有算子发通知确认cp完成，此时预提交阶段完成。
- sink收到确认通知后，就会正式提交之前的事务，外部系统中的数据才能被消费。
- 回滚：作业失败后，能将部分写入的结果回滚到写入之前的状态。
### 7.2、两阶段提交

两阶段提交（2PC），保证在分布式事务中，要么所有参与者都提交事务，要么都取消，即实现原子性。

两个角色：协调者（Coordinator）和参与者（Participant），协调者只有一个，用于管理所有节点执行逻辑，参与者有多个。

两阶段提交分为投票阶段和提交阶段：

- 投票阶段：
- 协调者向所有参与者发送prepare请求和事务内容，询问是否可以准备事务提交，等待参与者响应。
- 参与者执行事务操作，记录undo（用于回滚）和redo（用于重放）日志，但不真正提交。
- 参与者向协调者返回事务操作结果，执行成功返回yes，执行失败返回no。
- 提交阶段：
- 如果所有参与者都返回yes，说明事务可以提交：
- 协调者向所有参与者发送commit。
- 参与者收到commit后，将事务真正提交，向协调者返回ack。
- 协调者收到所有参与者ack，事务成功提交。
- 若有参与者返回no或超时未返回，说明事务中断，需要回滚：
- 协调者向所有参与者发送rollback请求。
- 参与者收到rollback后，根据undo日志回滚到事务执行之前，向协调者返回ack。
- 协调者收到所有参与者ack，事务回滚完成。
### **Exactly Once**

EOS：真正想表达的不是只被处理一次，而是数据**只影响最终结果有且只有一次，**需要处理的位置有三个（source 端、应用端、sink 端）

- source端：source 端比较简单，因为 flink 作为消费方，只需要保存偏移量就可以保证即使重启恢复也只消费一次
- 应用端：应用端也比较简单，是通过 CP 来实现的，CP 保存 flink 的状态，保存存盘，可以故障恢复，保证消息在内部的一致性
- sink 端：较为复杂，需要跟外部系统进行交互，如果出现问题需要回滚，比较经典的 Kafka（Kafka 对**事务的支持**是 flink EOS 的关键），flink 内部，**两个CP之间的这段写入就可以视为一个事务（因为可以用 CP 回滚），但并发出问题了，回滚一个就不能保证了**
- 2PC：两阶段提交就是解决上述问题，表决阶段 + 提交阶段，只有全票通过才能提交，否则回滚
![image](DaxJdUYveoyeERxVtivcXCysntb.png)

如果下级存储不支持事务，Flink 怎么保证 exactly-once

exactly-once 对 sink 要求很高，主要实现有**幂等写入**和**事务性写入（2 PC、WAL）**两种方式，在适用场景上，幂等写入依赖于业务逻辑，事务写入更常见。 事务性写分为 WAL 和 2PC，如果外部系统不支持事务，可以将结果数据当场状态保存，然后在收到 checkpoint 完成的通知时，一次性写入到 sink
